
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Fluid Dynamics Simulator v52.4</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js and OrbitControls CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Chart.js CDN for plotting -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <!-- MathJax Configuration (IMPORTANT for inline LaTeX) -->
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']] // Configure $ for inline math
          },
          svg: {
            fontCache: 'global' // Optimize font loading
          },
          options: {
            skipHtmlTags: ['script', 'noscript', 'textarea', 'pre', 'code', 'annotation', 'annotation-xml'],
            ignoreHtmlClass: 'no-mathjax' // Also ignore elements with this class
          }
        };
    </script>
    <!-- MathJax CDN for LaTeX rendering -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* Custom styles for better slider appearance */
        input[type='range']::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4F46E5; /* Indigo-600 */
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.3); /* Indigo-600 with opacity */
            margin-top: -6px; /* Adjust to center thumb on track */
        }
        input[type='range']::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4F46E5;
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.3);
        }

        /* Dynamic gradient for the slider track */
        input[type='range'] {
            -webkit-appearance: none; /* Override default browser styles */
            appearance: none;
            width: 100%;
            height: 4px; /* Height of the track */
            border-radius: 2px;
            outline: none; /* Remove focus outline */
            background: linear-gradient(to right,
                hsl(120, 60%, 85%) 0%,    /* Light Pastel Green */
                hsl(210, 70%, 75%) 33%,   /* Pastel Blue */
                hsl(270, 80%, 65%) 66%,   /* Pastel Purple */
                hsl(0, 90%, 55%) 100%     /* Pastel Red */
            );
            background-size: var(--slider-value-percent, 0%) 100%; /* Controls the fill amount */
            background-repeat: no-repeat;
            background-color: #E0E7FF; /* Color for the unfilled part of the track */
            transition: background-size 0.1s ease-out; /* Smooth transition for the gradient fill */
        }

        input[type='range']::-webkit-slider-runnable-track { background: transparent; }
        input[type='range']::-moz-range-track { background: transparent; }

        select {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='currentColor'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd'/%3E%3C/svg%3E");
            background-repeat: no-repeat; background-position: right 0.75rem center; background-size: 1.5em 1.5em; padding-right: 2.5rem;
        }

        /* Modal specific styles */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); justify-content: center; align-items: center; }
        .modal-content { background-color: #fefefe; margin: auto; padding: 20px; border-radius: 0.75rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); position: relative; max-width: 90%; max-height: 90%; overflow-y: auto; animation: fadeIn 0.3s ease-out; }
        .close-button { color: #aaa; float: right; font-size: 28px; font-weight: bold; position: absolute; top: 10px; right: 20px; }
        .close-button:hover, .close-button:focus { color: black; text-decoration: none; cursor: pointer; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }

        /* Spinner and Activity Indicator styles */
        .spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-top: 4px solid #fff; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; display: inline-block; vertical-align: middle; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes pulseColor { 0% { color: white; } 50% { color: #FECACA; } 100% { color: white; } }
        .pulsing-text { animation: pulseColor 1s ease-in-out infinite; }
        #simulationActivityIndicator { display: none; position: absolute; top: 1.5rem; right: 1.5rem; z-index: 10; display: flex; align-items: center; gap: 0.5rem; }
        .spinner.spinner-completed { animation: none; border-top-color: #10B981 !important; border-left-color: #10B981 !important; border-right-color: #10B981 !important; border-bottom-color: #10B981 !important; }

        /* Progress Bar styles */
        .progress-bar-container { position: relative; width: 100%; height: 0.625rem; background-color: #E0E7FF; border-radius: 9999px; margin-bottom: 1rem; overflow: hidden; }
        #progressBar { position: absolute; left: 0; top: 0; height: 100%; border-radius: 9999px; background-color: #4F46E5; transition: width 0.1s ease-out; }

        /* Dynamic Tooltip styles */
        #dynamicTooltip { position: absolute; background-color: rgba(31, 41, 55, 0.95); color: white; padding: 0.5rem 0.75rem; border-radius: 0.375rem; font-size: 0.75rem; line-height: 1rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); white-space: normal; max-width: 250px; z-index: 2000; pointer-events: none; opacity: 0; transition: opacity 0.2s ease-in-out; top: -9999px; left: -9999px; }
        #dynamicTooltip.show { opacity: 1; }
        .tooltip-grid { display: grid; grid-template-columns: auto 1fr; gap: 0.25rem 0.75rem; align-items: center; }
        .tooltip-grid-label { font-weight: 600; text-align: right; }

        /* 3D Visualization Container */
        #threeJsContainer, #threeJsSliceContainer, #threeJsGridContainer { 
            width: 100%; 
            height: 500px; 
            background-color: #f0f0f0; 
            border-radius: 0.5rem; 
            overflow: hidden; 
            cursor: grab; 
            position: relative; 
        }
        #threeJsContainer:active, #threeJsSliceContainer:active, #threeJsGridContainer:active { 
            cursor: grabbing; 
        }
        
        #threeJsSliceContainer, #threeJsGridContainer {
             width: 400px;
             height: 400px;
             background-color: #e5e7eb; /* gray-200 */
        }


        /* Color Legend Styles */
        .color-legend-container { display: flex; align-items: center; justify-content: space-between; width: 100%; margin-bottom: 1rem; padding: 0.5rem 0; font-size: 0.875rem; color: #374151; }
        .color-gradient { flex-grow: 1; height: 16px; background: linear-gradient(to right, hsl(120, 90%, 60%), hsl(60, 90%, 60%), hsl(0, 90%, 60%)); border-radius: 8px; margin: 0 0.5rem; box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }
        .legend-label { white-space: nowrap; font-weight: 500; }

        .text-green-600-custom { color: #16A34A; }

        /* Style for disabled playback controls */
        .playback-disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        /* Tab styles */
        .tab-button.active-tab {
            color: #4f46e5; /* indigo-600 */
            border-bottom-width: 2px;
            border-color: #4f46e5; /* indigo-600 */
        }
        .tab-button.inactive-tab {
            color: #6b7280; /* gray-500 */
            border-bottom-width: 2px;
            border-color: transparent;
        }
        .tab-button.inactive-tab:hover {
            color: #374151; /* gray-700 */
            border-color: #d1d5db; /* gray-300 */
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        /* 2D Slice Viewer Grid styles */
        #sliceGridContainer {
            display: grid;
            grid-template-columns: repeat(var(--slice-grid-n, 16), 1fr);
            grid-template-rows: repeat(var(--slice-grid-n, 16), 1fr);
            width: 400px;
            height: 400px;
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 0.375rem;
            background-color: #f9fafb; /* gray-50 */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border-right: none;
            border-bottom: none;
            cursor: pointer;
        }
        .slice-grid-cell {
            position: relative;
            overflow: hidden;
            border-right: 1px solid rgba(0, 0, 0, 0.1);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            transition: background-color 0.4s ease-out;
        }
        .slice-grid-cell:nth-child(var(--slice-grid-n)n) { border-right: none; }
        .slice-grid-cell:nth-last-child(-n+var(--slice-grid-n)) { border-bottom: none; }

        /* Fading highlight effect for hovered cell */
        .slice-grid-cell-highlight {
             background-color: rgba(255, 255, 255, 0.6) !important;
             transition: background-color 0.05s ease-in;
        }
        /* Outline for selected cell */
        .slice-grid-cell-selected {
            outline: 2px solid #cccccc;
            outline-offset: -2px;
            z-index: 10;
        }
        /* Outline for multi-selected cells */
        .slice-grid-cell-multiselected {
            outline: 1px solid #374151; /* Dark Gray */
            outline-offset: -1px;
            z-index: 5;
        }

    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body class="bg-gray-50 font-sans antialiased text-gray-800 p-4 sm:p-6">

    <div class="max-w-7xl mx-auto">
        <div class="text-center mb-4">
            <h1 class="font-bold tracking-widest text-gray-600" style="font-size: 10pt;"><span style="color: #FF0000;">Q</span> <span style="color: #0000FF;">U</span> A N T U M &nbsp; Q &nbsp; | &nbsp; R E S E A R C H &nbsp;&nbsp; &amp; &nbsp;&nbsp; D E V E L O P M E N T &nbsp;&nbsp; D I V I S I O N &nbsp; | &nbsp; 2 0 2 5 &copy;</h1>
        </div>
    </div>

    <div class="max-w-7xl mx-auto bg-white shadow-lg rounded-xl p-6 sm:p-8 border border-gray-200" id="mainContentArea">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-center text-indigo-700 mb-2">3D Fluid Dynamics Simulator</h1>
        <p class="text-center text-sm text-gray-700 font-semibold mb-8 tracking-wider">
            A CONCEPTUAL 3D INCOMPRESSIBLE FLUID DYNAMICS MODEL
        </p>

        <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-md relative mb-8 text-left" role="alert">
            <strong class="font-bold">CRITICAL NOTE FOR RESEARCHERS:</strong>
            <span class="block sm:inline">This simulator provides a **conceptual visualization** of 3D incompressible fluid dynamics. It is **NOT** a direct, high-fidelity simulation of the 3D Navier-Stokes equations and cannot be used to prove or disprove the Navier-Stokes existence and smoothness conjecture. Its purpose is for conceptual understanding of related phenomena.
            <br><br><strong>BETA SOFTWARE NOTICE:</strong> This application is under active development (beta stage). While we strive for accuracy and stability, bugs or unexpected behaviors may be present. Your use of this tool acknowledges this experimental status.
            </span>
        </div>

        <div class="flex flex-col lg:flex-row gap-6">
            <!-- Left Panel: Parameters and Controls -->
            <div class="lg:w-2/5 bg-gray-50 p-6 rounded-lg border border-gray-200 shadow-md" id="parameterSection">
                <h2 class="text-2xl font-bold text-gray-700 mb-6">Simulation Parameters</h2>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-y-6 gap-x-4 mb-8">
                    <!-- Grid Resolution -->
                    <div>
                        <label for="paramGridSize" class="block text-sm font-medium text-gray-600 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Grid Resolution (N)</p><p class='text-xs mb-2 text-gray-300'>The number of discrete points along each axis (NxNxN). Higher N provides higher spatial resolution but is computationally intensive.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>Total cells = $N^3$</p></div>">Grid Resolution (N):</label>
                        <div class="flex items-center gap-x-3 mt-1">
                            <input type="range" id="paramGridSize" min="8" max="32" step="4" value="16" class="w-full">
                            <input type="number" id="inputGridSize" min="8" max="32" step="4" value="16" class="bg-white p-1 border border-gray-300 rounded-md shadow-sm text-sm text-center" style="width: 5rem;">
                        </div>
                    </div>
                    <!-- Kinematic Viscosity -->
                    <div>
                        <label for="paramViscosity" class="block text-sm font-medium text-gray-600 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Kinematic Viscosity ($\nu$)</p><p class='text-xs mb-2 text-gray-300'>Controls fluid friction and energy dissipation. Higher $\nu$ leads to smoother, more stable flows.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>Term: $\nu \nabla^2 \mathbf{u}$</p></div>">Kinematic Viscosity ($\nu$):</label>
                        <div class="flex items-center gap-x-3 mt-1">
                            <input type="range" id="paramViscosity" min="0.001" max="0.1" step="0.001" value="0.01" class="w-full">
                            <input type="number" id="inputViscosity" min="0.001" max="0.1" step="0.001" value="0.010" class="bg-white p-1 border border-gray-300 rounded-md shadow-sm text-sm text-center" style="width: 5rem;">
                        </div>
                    </div>
                    <!-- Time Step -->
                    <div>
                        <label for="paramDt" class="block text-sm font-medium text-gray-600 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Time Step ($\Delta t$)</p><p class='text-xs mb-2 text-gray-300'>The duration of each simulation step. Smaller values increase accuracy but take longer.</p></div>">Time Step ($\Delta t$):</label>
                        <div class="flex items-center gap-x-3 mt-1">
                            <input type="range" id="paramDt" min="0.001" max="0.1" step="0.001" value="0.01" class="w-full">
                            <input type="number" id="inputDt" min="0.001" max="0.1" step="0.001" value="0.010" class="bg-white p-1 border border-gray-300 rounded-md shadow-sm text-sm text-center" style="width: 5rem;">
                        </div>
                    </div>
                     <!-- Simulation Duration -->
                    <div>
                        <label for="paramSimTime" class="block text-sm font-medium text-gray-600 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Simulation Steps</p><p class='text-xs mb-2 text-gray-300'>Total number of time steps to run the simulation for.</p></div>">Simulation Steps:</label>
                        <div class="flex items-center gap-x-3 mt-1">
                            <input type="range" id="paramSimTime" min="100" max="2000" step="100" value="500" class="w-full">
                            <input type="number" id="inputSimTime" min="100" max="2000" step="100" value="500" class="bg-white p-1 border border-gray-300 rounded-md shadow-sm text-sm text-center" style="width: 5rem;">
                        </div>
                    </div>
                    <!-- Initial Condition -->
                    <div class="col-span-full flex flex-col">
                        <label for="paramInitCondition" class="text-sm font-medium text-gray-600 mb-1 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Initial Condition</p><p class='text-xs text-gray-300'>The starting state of the fluid at time $t=0$.</p></div>">Initial Condition:</label>
                        <select id="paramInitCondition" class="bg-white block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-base h-10">
                            <option value="vortex">Single Vortex</option>
                            <option value="jet">Central Jet</option>
                            <option value="random">Random Noise</option>
                        </select>
                    </div>
                    <!-- Visualization Mode -->
                    <div class="col-span-full flex flex-col">
                        <label for="paramVisualization" class="text-sm font-medium text-gray-600 mb-1 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Visualization Mode</p><p class='text-xs text-gray-300'>Selects which physical quantity to display in the 3D view.</p></div>">Visualization Mode:</label>
                        <select id="paramVisualization" class="bg-white block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-base h-10">
                            <option value="velocity">Velocity Vectors</option>
                            <option value="density">Density (Passive Scalar)</option>
                            <option value="vorticity">Vorticity Magnitude</option>
                        </select>
                    </div>
                    <!-- Enable Tooltips Checkbox -->
                    <div class="col-span-full flex items-center mt-4">
                        <input type="checkbox" id="enableTooltips" class="form-checkbox h-4 w-4 text-indigo-600 transition duration-150 ease-in-out rounded-md cursor-pointer">
                        <label for="enableTooltips" class="ml-2 text-sm font-medium text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Enable Tooltips</p><p class='text-xs text-gray-300'>Toggle dashboard-wide tooltips for mathematical equations and important labels.</p></div>">Enable Equation Tooltips</label>
                    </div>
                </div>

                <!-- Simulation Presets -->
                <div class="mt-6">
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Simulation Presets:</h3>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
                        <button id="presetStableFlow" class="px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Preset: Stable Flow</p><p class='text-xs text-gray-300'>Demonstrates a stable, high-viscosity flow where initial energy dissipates smoothly.</p></div>">Stable Flow</button>
                        <button id="presetTurbulence" class="px-4 py-2 bg-red-600 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Preset: Turbulence</p><p class='text-xs text-gray-300'>Highlights low-viscosity conditions leading to complex, chaotic, turbulent-like behavior.</p></div>">Turbulence</button>
                        <button id="presetVortexStretching" class="px-4 py-2 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Preset: Vortex Stretching</p><p class='text-xs text-gray-300'>Visualizes the advection and intensification of a vortex structure, a key mechanism in turbulence.</p></div>">Vortex Stretching</button>
                        <button id="presetDensityTransport" class="px-4 py-2 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Preset: Density Transport</p><p class='text-xs text-gray-300'>Shows how a passive scalar (like dye) is transported and mixed by the fluid flow.</p></div>">Density Transport</button>
                    </div>
                </div>

                <!-- Simulation Controls -->
                <h3 class="text-lg font-semibold text-gray-700 mt-6 mb-3">Simulation Controls:</h3>
                <div class="flex flex-col sm:flex-row justify-around gap-4 mb-4">
                    <button id="btnRun" class="flex-1 px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10 cursor-pointer" title="Start Simulation">
                        <span id="btnRunContent" class="flex items-center justify-center">
                            <svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197 2.132A1 1 0 0110 13.82V9.18a1 1 0 011.555-.832l3.197 2.132a1 1 0 010 1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                            Simulation
                        </span>
                    </button>
                    <button id="btnPauseResume" class="flex-1 px-4 py-2 bg-yellow-500 text-white font-semibold rounded-lg shadow-md hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-offset-2 transition ease-in-out duration-150 opacity-50 cursor-not-allowed h-10" disabled title="Pause Simulation">
                        <svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg> Pause
                    </button>
                </div>
                <div class="flex flex-col sm:flex-row justify-around gap-4">
                    <button id="btnRefresh" class="flex-1 px-4 py-2 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10 cursor-pointer" title="Refresh Dashboard">
                        <svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004 12c0 2.21.817 4.231 2.105 5.786M20 20v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
                        Refresh
                    </button>
                    <button id="btnExport" class="flex-1 px-4 py-2 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition ease-in-out duration-150 opacity-50 cursor-not-allowed h-10" disabled title="Export Data">
                        <svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"></path></svg>
                        Export Data
                    </button>
                </div>
                <div class="flex justify-around gap-4 mt-4">
                    <button id="btnHelp" class="flex-1 px-4 py-2 bg-gray-600 text-white font-semibold rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10 flex items-center justify-center cursor-pointer" title="How to Interpret the Dashboard">
                        How to Interpret this Dashboard
                    </button>
                </div>
            </div>

            <!-- Right Panel: Live Visualization -->
            <div class="lg:w-3/5 bg-gray-50 p-6 rounded-lg border border-gray-200 shadow-md relative">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold text-gray-700">Live Simulation <span id="liveSimSubtitle" class="ml-2 text-base font-semibold"></span></h2>
                    <div id="simulationActivityIndicator" class="hidden">
                        <span id="percentageCounter" class="text-sm font-semibold text-gray-700">0%</span>
                        <span class="spinner w-8 h-8 !border-t-green-500 !border-gray-300"></span>
                    </div>
                </div>
                <div class="progress-bar-container">
                    <div id="progressBar" class="bg-indigo-600 h-full rounded-full transition-all duration-100 ease-out" style="width: 0%;"></div>
                </div>
                 <!-- Color Legend for 3D Visualization -->
                <div class="color-legend-container">
                    <span class="legend-label left">Low Vorticity</span>
                    <div class="color-gradient"></div>
                    <span class="legend-label right">High Vorticity</span>
                </div>
                <div id="threeJsContainer" class="relative bg-gray-200 rounded-lg shadow-inner border border-gray-300">
                     <p id="performanceWarning" class="absolute top-2 left-2 text-xs text-white bg-black bg-opacity-50 p-1 rounded hidden z-10">
                        High grid resolution may cause slowdowns.
                    </p>
                </div>
                <!-- Simulation Playback Controls -->
                <div id="playbackControls" class="mt-4 bg-white rounded-lg p-4 shadow-inner border border-gray-300 playback-disabled">
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Simulation Playback</h3>
                    <div class="flex items-center gap-2">
                        <input type="range" id="playbackSlider" min="0" max="1" step="1" value="0" class="w-full" disabled>
                        <button id="btnReplay" class="flex-shrink-0 p-1.5 bg-gray-200 hover:bg-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" title="Play/Pause Replay">
                            <svg id="replayPlayIcon" class="w-4 h-4 text-gray-700" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M15.312 11.424a5.5 5.5 0 01-9.204 2.102l-.693.693a6.5 6.5 0 0010.99-2.495l-1.093-.3ZM4.688 8.576a5.5 5.5 0 019.204-2.102l.693-.693a6.5 6.5 0 00-10.99 2.495l1.093.3Z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M5.53 4.843a.75.75 0 011.054.08l1.497 1.684a.75.75 0 11-1.134.996L5.45 5.925a.75.75 0 01.08-1.082Zm9.94 9.227a.75.75 0 01-1.054-.08l-1.497-1.684a.75.75 0 111.134-.996l1.496 1.684a.75.75 0 01-.08 1.082Z" clip-rule="evenodd"/></svg>
                            <svg id="replayPauseIcon" class="w-4 h-4 text-gray-700 hidden" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5 4.75A.75.75 0 015.75 4h2.5A.75.75 0 019 4.75v10.5A.75.75 0 018.25 16h-2.5A.75.75 0 015 15.25V4.75zm6.5.75A.75.75 0 0010.75 4h2.5a.75.75 0 01.75.75v10.5a.75.75 0 01-.75.75h-2.5a.75.75 0 01-.75-.75V5.5z" clip-rule="evenodd"></path></svg>
                        </button>
                    </div>
                    <div class="flex justify-between text-xs text-gray-500 mt-1">
                        <span id="playbackCurrentTime">Step: 0</span>
                        <span id="playbackTotalTime">Total: 0</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Simulation Metrics Section -->
        <div class="mt-8 bg-gray-50 p-6 rounded-lg border border-gray-200 shadow-md">
            <h2 class="text-2xl font-bold text-gray-700 mb-6">Simulation Metrics</h2>
            <div id="metricsContent" class="p-4 bg-white rounded-b-lg shadow-inner border border-gray-300">
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-4">
                    <div>
                        <h3 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Kinetic Energy ($E_k$)</p><p class='text-xs mb-2 text-gray-300'>The total energy of motion in the fluid. Tends to decay over time due to viscosity.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$E_k = \frac{1}{2} \int |\mathbf{u}|^2 dV$</p></div>">Kinetic Energy ($E_k$):</h3>
                        <p class="text-gray-600">Current: <span id="metricKE_current" class="font-mono">0.0000</span></p>
                        <p class="text-gray-600">Max Overall: <span id="metricKE_max" class="font-mono">0.0000</span></p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Enstrophy ($\mathcal{E}$)</p><p class='text-xs mb-2 text-gray-300'>The intensity of vorticity (swirling motion). High enstrophy is a hallmark of turbulence.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$\mathcal{E} = \frac{1}{2} \int |\omega|^2 dV$</p></div>">Enstrophy ($\mathcal{E}$):</h3>
                        <p class="text-gray-600">Current: <span id="metricEnstrophy_current" class="font-mono">0.0000</span></p>
                        <p class="text-gray-600">Max Overall: <span id="metricEnstrophy_max" class="font-mono">0.0000</span></p>
                    </div>
                     <div>
                        <h3 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Helicity ($\mathcal{H}$)</p><p class='text-xs mb-2 text-gray-300'>Measures the 'knottedness' of vortex lines. Important for characterizing turbulent structures.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$\mathcal{H} = \int \mathbf{u} \cdot \omega \, dV$</p></div>">Helicity ($\mathcal{H}$):</h3>
                        <p class="text-gray-600">Current: <span id="metricHelicity_current" class="font-mono">0.0000</span></p>
                        <p class="text-gray-600">Max Overall: <span id="metricHelicity_max" class="font-mono">0.0000</span></p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Max Velocity ($|\mathbf{u}|_{max}$)</p><p class='text-xs mb-2 text-gray-300'>The highest speed found anywhere in the fluid domain at the current time.</p></div>">Max Velocity:</h3>
                        <p class="text-gray-600">Current: <span id="metricMaxVel_current" class="font-mono">0.000</span></p>
                        <p class="text-gray-600">Max Overall: <span id="metricMaxVel_max" class="font-mono">0.000</span></p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Max Vorticity ($|\omega|_{max}$)</p><p class='text-xs mb-2 text-gray-300'>The strongest local rotation in the fluid. A key value for studying potential singularities.</p></div>">Max Vorticity:</h3>
                        <p class="text-gray-600">Current: <span id="metricMaxVort_current" class="font-mono">0.000</span></p>
                        <p class="text-gray-600">Max Overall: <span id="metricMaxVort_max" class="font-mono">0.000</span></p>
                    </div>
                    <div class="col-span-1 md:col-span-1 lg:col-span-1">
                        <h3 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Average Divergence ($|\nabla \cdot \mathbf{u}|$)</p><p class='text-xs mb-2 text-gray-300'>Measures numerical error in preserving the incompressibility condition. Should be close to zero.</p></div>">Average Divergence:</h3>
                        <p class="text-gray-600">Current: <span id="metricAvgDiv_current" class="font-mono">0.0000</span></p>
                    </div>
                </div>
                <h3 class="font-semibold text-gray-700 mb-2">Time Series Plots:</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div class="w-full bg-gray-100 rounded-md border border-gray-300 p-2 relative">
                        <canvas id="keChartCanvas" class="w-full h-48"></canvas>
                    </div>
                    <div class="w-full bg-gray-100 rounded-md border border-gray-300 p-2 relative">
                        <canvas id="enstrophyChartCanvas" class="w-full h-48"></canvas>
                    </div>
                    <div class="w-full bg-gray-100 rounded-md border border-gray-300 p-2 relative">
                        <canvas id="helicityChartCanvas" class="w-full h-48"></canvas>
                    </div>
                    <div class="w-full bg-gray-100 rounded-md border border-gray-300 p-2 relative">
                        <canvas id="maxVortChartCanvas" class="w-full h-48"></canvas>
                    </div>
                </div>

                <div class="flex flex-col items-center mt-6">
                    <div class="grid grid-cols-2 gap-4 w-full max-w-md">
                        <button id="btnResults" class="px-6 py-3 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10 cursor-pointer" disabled title="Interpret Current Simulation State">
                            <span class="flex items-center justify-center">✨ Results</span>
                        </button>
                        <button id="btnInterpretKids" class="px-6 py-3 bg-blue-400 text-white font-semibold rounded-lg shadow-md hover:bg-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-300 focus:ring-offset-2 transition ease-in-out duration-150 h-10 cursor-pointer" disabled title="Ask Einstein for a simple explanation">
                            <span class="flex items-center justify-center">✨ Ask Einstein</span>
                        </button>
                        <button id="btnQA" class="px-6 py-3 bg-orange-500 text-white font-semibold rounded-lg shadow-md hover:bg-orange-600 focus:outline-none focus:ring-2 focus:ring-orange-400 focus:ring-offset-2 transition ease-in-out duration-150 h-10 cursor-pointer" disabled title="Generate Questions & Answers">
                            <span class="flex items-center justify-center">✨ Q&A</span>
                        </button>
                        <button id="btnConversation" class="px-6 py-3 bg-emerald-500 text-white font-semibold rounded-lg shadow-md hover:bg-emerald-600 focus:outline-none focus:ring-2 focus:ring-emerald-400 focus:ring-offset-2 transition ease-in-out duration-150 h-10 flex items-center justify-center cursor-pointer" title="Listen to a conversation about Navier-Stokes">
                            Conversation
                        </button>
                        <audio id="navierStokesAudio" src="https://quantumq-ai.github.io/QQ_1D_Navier_Stokes_Conjecture_Simulator/NavierStokesConversation.mp3" preload="auto"></audio>
                    </div>
                    <div class="mt-4 w-full max-w-md text-center">
                        <input type="password" id="geminiApiKeyInput" placeholder="Enter Gemini API Key to enable interpretation" class="bg-white w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-purple-500 focus:border-purple-500 text-sm text-center">
                        <p class="text-xs text-gray-600 mt-2">INTERNET CONNECTION REQUIRED TO USE AI INTEGRATION</p>
                        <a href="#" id="getApiKeyLink" class="font-bold text-blue-600 hover:text-blue-800 text-xs no-underline mt-2 inline-block cursor-pointer">HOW TO ACQUIRE A GEMINI KEY</a>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tabbed Results Section -->
        <div class="mt-8 bg-gray-50 p-6 rounded-lg border border-gray-200 shadow-md">
            <h2 class="text-2xl font-bold text-gray-700 mb-6">Detailed Analysis</h2>

            <div class="flex border-b border-gray-200">
                <button id="tabDistribution" class="tab-button active-tab px-4 py-2 text-sm font-medium focus:outline-none transition duration-150 ease-in-out cursor-pointer" data-tab="distributionContent">Distribution Analysis</button>
                <button id="tabSpectrum" class="tab-button inactive-tab px-4 py-2 text-sm font-medium focus:outline-none transition duration-150 ease-in-out cursor-pointer" data-tab="spectrumContent">Energy Spectrum</button>
                <button id="tabSlicing" class="tab-button inactive-tab px-4 py-2 text-sm font-medium focus:outline-none transition duration-150 ease-in-out cursor-pointer" data-tab="slicingContent">2D Slice Viewer</button>
                <button id="tabSlicing3D" class="tab-button inactive-tab px-4 py-2 text-sm font-medium focus:outline-none transition duration-150 ease-in-out cursor-pointer" data-tab="slicingContent3D">3D Slice Viewer</button>
            </div>

            <div id="detailedResultsContent" class="p-4 bg-white rounded-b-lg shadow-inner border border-gray-300 min-h-[20rem]">
                <div id="derivedMetricsWrapper" class="hidden mb-8">
                    <h3 class="text-lg font-semibold text-gray-700 mb-4">Derived Physical Quantities (at final state):</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        <!-- Reynolds Number -->
                        <div class="bg-gray-100 p-4 rounded-lg border border-gray-200 shadow-sm">
                            <h4 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Reynolds Number ($Re$)</p><p class='text-xs mb-2 text-gray-300'>A dimensionless number indicating the flow regime. Low Re signifies laminar flow, high Re signifies turbulent flow.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$Re = \frac{UL}{\nu} \approx \frac{\sqrt{2 E_k}}{\nu}$</p></div>">Reynolds Number ($Re$)</h4>
                            <p id="metricRe" class="font-mono text-2xl text-indigo-600 mt-1">0.00</p>
                            <p class="text-xs text-gray-500 mt-2">Ratio of inertial to viscous forces. Higher values suggest more turbulent-like flow.</p>
                        </div>
                        <!-- Taylor Reynolds Number -->
                        <div class="bg-gray-100 p-4 rounded-lg border border-gray-200 shadow-sm">
                            <h4 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Taylor Reynolds Number ($Re_{\lambda}$)</p><p class='text-xs mb-2 text-gray-300'>A Reynolds number based on the Taylor microscale, characterizing small-scale turbulence.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$Re_{\lambda} = \frac{\sqrt{2} E_k}{\nu \sqrt{\mathcal{E}}}$</p></div>">Taylor Reynolds Number ($Re_{\lambda}$)</h4>
                            <p id="metricReTaylor" class="font-mono text-2xl text-indigo-600 mt-1">0.00</p>
                            <p class="text-xs text-gray-500 mt-2">Characterizes turbulence at intermediate scales, where vortex stretching is significant.</p>
                        </div>
                        <!-- Energy Dissipation Rate -->
                        <div class="bg-gray-100 p-4 rounded-lg border border-gray-200 shadow-sm">
                            <h4 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Energy Dissipation ($\epsilon$)</p><p class='text-xs mb-2 text-gray-300'>The rate at which kinetic energy is converted to thermal energy by viscosity.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$\epsilon = 2\nu\mathcal{E}$</p></div>">Energy Dissipation ($\epsilon$)</h4>
                            <p id="metricEpsilon" class="font-mono text-2xl text-red-600 mt-1">0.00</p>
                            <p class="text-xs text-gray-500 mt-2">Rate of energy loss due to fluid friction. Measured in $m^2/s^3$.</p>
                        </div>
                        <!-- Kolmogorov Length Scale -->
                        <div class="bg-gray-100 p-4 rounded-lg border border-gray-200 shadow-sm">
                            <h4 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Kolmogorov Scale ($\eta$)</p><p class='text-xs mb-2 text-gray-300'>The smallest length scale in a turbulent flow, where dissipation occurs.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$\eta = (\nu^3 / \epsilon)^{1/4}$</p></div>">Kolmogorov Scale ($\eta$)</h4>
                            <p id="metricEta" class="font-mono text-2xl text-green-700 mt-1">0.00</p>
                            <p class="text-xs text-gray-500 mt-2">The smallest eddies where energy dissipates into heat. Measured in meters.</p>
                        </div>
                        <!-- Integral Length Scale -->
                        <div class="bg-gray-100 p-4 rounded-lg border border-gray-200 shadow-sm">
                            <h4 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Integral Scale ($L_{int}$)</p><p class='text-xs mb-2 text-gray-300'>An estimate of the size of the largest eddies in the flow.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$L_{int} \approx \frac{(E_k)^{3/2}}{\epsilon}$</p></div>">Integral Scale ($L_{int}$)</h4>
                            <p id="metricLInt" class="font-mono text-2xl text-blue-600 mt-1">0.00</p>
                            <p class="text-xs text-gray-500 mt-2">The size of the largest, energy-containing eddies in the flow. Measured in meters.</p>
                        </div>
                        <!-- Resolution Ratio -->
                        <div class="bg-gray-100 p-4 rounded-lg border border-gray-200 shadow-sm">
                            <h4 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Resolution Ratio ($\Delta x / \eta$)</p><p class='text-xs mb-2 text-gray-300'>Compares grid spacing to the smallest turbulent scale. Values > 1 suggest under-resolved turbulence.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>Ratio = $\Delta x / \eta$</p></div>">Resolution Ratio ($\Delta x / \eta$)</h4>
                            <p id="metricDxEtaRatio" class="font-mono text-2xl text-purple-600 mt-1">0.00</p>
                            <p class="text-xs text-gray-500 mt-2">Measures if the grid is fine enough to capture the smallest eddies. > 1 is under-resolved.</p>
                        </div>
                    </div>
                </div>

                <!-- SHARED SLICE CONTROLS -->
                <div id="sliceControlsContainer" class="hidden grid-cols-1 sm:grid-cols-3 gap-4 mb-4 items-center bg-gray-100 p-3 rounded-md">
                    <div>
                        <label for="sliceVariableSelect" class="block text-sm font-medium text-gray-700 mb-1">Variable</label>
                        <select id="sliceVariableSelect" class="bg-white block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-base h-10">
                            <option value="vorticity">Vorticity Mag.</option>
                            <option value="velocity">Velocity Mag.</option>
                            <option value="pressure">Pressure</option>
                        </select>
                    </div>
                    <div>
                        <label for="sliceAxisSelect" class="block text-sm font-medium text-gray-700 mb-1">Slice Axis</label>
                        <select id="sliceAxisSelect" class="bg-white block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-base h-10">
                            <option value="z">Z-Axis</option>
                            <option value="y">Y-Axis</option>
                            <option value="x">X-Axis</option>
                        </select>
                    </div>
                    <div>
                        <label for="sliceIndexSlider" class="block text-sm font-medium text-gray-700 mb-1">Slice Index: <span id="sliceIndexLabel">0</span></label>
                        <div class="flex items-center gap-2">
                            <input type="range" id="sliceIndexSlider" min="1" max="16" value="8" class="w-full">
                            <button id="btnSlicePlayPause" class="flex-shrink-0 p-1.5 bg-gray-200 hover:bg-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" title="Play/Pause Slice Animation">
                                <svg id="slicePlayIcon" class="w-4 h-4 text-gray-700" fill="currentColor" viewBox="0 0 20 20"><path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z"></path></svg>
                                <svg id="slicePauseIcon" class="w-4 h-4 text-gray-700 hidden" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5 4.75A.75.75 0 015.75 4h2.5A.75.75 0 019 4.75v10.5A.75.75 0 018.25 16h-2.5A.75.75 0 015 15.25V4.75zm6.5.75A.75.75 0 0010.75 4h2.5a.75.75 0 01.75.75v10.5a.75.75 0 01-.75.75h-2.5a.75.75 0 01-.75-.75V5.5z" clip-rule="evenodd"></path></svg>
                            </button>
                        </div>
                    </div>
                </div>

                <div id="distributionContent" class="tab-content active">
                    <h3 class="text-lg font-semibold text-gray-700 mb-2">Final State Distribution Plots:</h3>
                     <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div class="w-full bg-gray-100 rounded-md border border-gray-300 p-2 relative cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Velocity Magnitude Distribution</p><p class='text-xs mb-2 text-gray-300'>This histogram shows the distribution of fluid speeds. It reveals if the flow is dominated by high-speed regions or is relatively uniform.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$|\mathbf{u}| = \sqrt{u^2 + v^2 + w^2}$</p></div>">
                            <canvas id="velocityDistChartCanvas" class="w-full h-64"></canvas>
                        </div>
                        <div class="w-full bg-gray-100 rounded-md border border-gray-300 p-2 relative cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Vorticity Magnitude Distribution</p><p class='text-xs mb-2 text-gray-300'>This histogram shows the distribution of vorticity (local spin) magnitudes. Turbulent flows have a broad distribution with long tails, indicating intense rotation.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$|\omega|$, where $\omega = \nabla \times \mathbf{u}$</p></div>">
                            <canvas id="vorticityDistChartCanvas" class="w-full h-64"></canvas>
                        </div>
                         <div class="w-full bg-gray-100 rounded-md border border-gray-300 p-2 relative cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Pressure Distribution</p><p class='text-xs mb-2 text-gray-300'>This histogram shows the distribution of pressure, which enforces incompressibility. Gradients in pressure create the forces that accelerate the fluid.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$\nabla^2 p = -\rho \nabla \cdot ((\mathbf{u} \cdot \nabla)\mathbf{u})$</p></div>">
                            <canvas id="pressureDistChartCanvas" class="w-full h-64"></canvas>
                        </div>
                        <div class="w-full bg-gray-100 rounded-md border border-gray-300 p-2 relative cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Helicity Cosine Distribution</p><p class='text-xs mb-2 text-gray-300'>Plots the cosine of the angle between velocity and vorticity. Peaks near +/-1 indicate stable helical structures. A peak at 0 is typical for disorganized turbulence.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$\cos(\theta) = \frac{\mathbf{u} \cdot \omega}{|\mathbf{u}| |\omega|}$</p></div>">
                            <canvas id="helicityCosineDistChartCanvas" class="w-full h-64"></canvas>
                        </div>
                    </div>
                </div>

                <div id="spectrumContent" class="tab-content">
                    <h3 class="text-lg font-semibold text-gray-700 mb-2">Kinetic Energy Spectrum (at final state)</h3>
                    <p class="text-xs text-gray-600 mb-4">This log-log plot shows how kinetic energy is distributed across different length scales (wavenumbers, k). For developed turbulence, a slope of -5/3 (Kolmogorov spectrum) is expected in the inertial range.</p>
                    <div class="w-full bg-gray-100 rounded-md border border-gray-300 p-2 relative h-96">
                        <canvas id="energySpectrumChartCanvas"></canvas>
                    </div>
                </div>
                
                <div id="slicingContent" class="tab-content">
                    <h3 class="text-lg font-semibold text-gray-700 mb-2">2D Slice Viewer (at final state)</h3>
                    <p id="multiSelectActiveMessage" class="hidden text-sm font-semibold text-center text-gray-700 bg-gray-100 border border-gray-300 rounded-md py-1 px-3 my-2 mx-auto w-full max-w-[400px] lg:max-w-[824px]">
                        Multi-Pixel Analysis Active: Single-click to add/remove points, double-click grid to analyze.
                    </p>
                    <div class="flex flex-col lg:flex-row justify-center items-start gap-6 mt-4">
                        <!-- Left Column: Graphical view and its color bar -->
                        <div class="flex flex-col items-center">
                            <canvas id="sliceCanvas" width="400" height="400" class="border border-gray-400 rounded-md shadow-lg" style="cursor:pointer;"></canvas>
                            <div class="mt-2 w-full max-w-[400px]">
                                <canvas id="sliceColorbarCanvas" width="400" height="20" class="w-full h-5 border border-gray-400 rounded-md"></canvas>
                                <div class="flex justify-between w-full text-xs mt-1">
                                    <span id="sliceColorbarMin">0.0</span>
                                    <span id="sliceColorbarMax">1.0</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Right Column: Numerical Slice Grid -->
                        <div class="flex flex-col items-center">
                            <div id="sliceGridContainer" class="flex-shrink-0">
                                <!-- JS will populate this with a grid of divs -->
                            </div>
                             <!-- NEW Info Panel: Positioned under the grid, horizontally aligned with the color bar -->
                            <div class="flex justify-between items-center w-full max-w-[400px] mt-2">
                                <!-- Value display on the left -->
                                <div class="text-sm text-gray-600 flex items-center">
                                    <span>Value (<span id="sliceValueSymbol">$N/A$</span>):</span>
                                    <span id="sliceLiveValue" class="font-mono font-bold bg-white border border-gray-300 py-1 px-2 rounded-md ml-2 inline-block min-w-[7em] text-center shadow-sm">N/A</span>
                                </div>
                                <!-- Checkbox on the right -->
                                <div class="flex items-center">
                                     <input type="checkbox" id="multiSelectCheckbox" class="form-checkbox h-4 w-4 text-indigo-600 transition duration-150 ease-in-out rounded-md cursor-pointer">
                                     <label for="multiSelectCheckbox" class="ml-2 text-sm font-medium text-gray-700 cursor-pointer">Enable Multi-Pixel Analysis</label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="slicingContent3D" class="tab-content">
                    <h3 class="text-lg font-semibold text-gray-700 mb-2">3D Volumetric & Slice Grid Viewer (at final state)</h3>
                    <p class="text-xs text-gray-600 mb-4">The left view shows the entire 3D data volume for the selected variable. The right view shows a 3D bar-chart representation of the currently selected 2D slice, which you can change using the controls above. Both views are interactive (Left-click to rotate, Right-click to pan, Scroll to zoom).</p>
                    <div class="flex flex-col lg:flex-row justify-center items-start gap-6 mt-4">
                        <!-- Left Column: 3D Volumetric View -->
                        <div class="flex flex-col items-center">
                            <div id="threeJsSliceContainer" class="relative"></div>
                            <p class="text-xs text-center mt-2 text-gray-600">Full 3D Volumetric View</p>
                            <div class="mt-2 w-full max-w-[400px]">
                                <canvas id="volumeColorbarCanvas" width="400" height="20" class="w-full h-5 border border-gray-400 rounded-md"></canvas>
                                <div class="flex justify-between w-full text-xs mt-1">
                                    <span id="volumeColorbarMin">0.0</span>
                                    <span id="volumeColorbarMax">1.0</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Right Column: 3D Grid View of Slice -->
                        <div class="flex flex-col items-center">
                            <div id="threeJsGridContainer" class="relative"></div>
                             <p class="text-xs text-center mt-2 text-gray-600">3D Grid View of Current Slice (Rotatable)</p>
                             <div class="mt-2 w-full max-w-[400px]">
                                <canvas id="gridColorbarCanvas" width="400" height="20" class="w-full h-5 border border-gray-400 rounded-md"></canvas>
                                <div class="flex justify-between w-full text-xs mt-1">
                                    <span id="gridColorbarMin">0.0</span>
                                    <span id="gridColorbarMax">1.0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="analysisPlaceholderWrapper" class="active">
                    <p id="analysisPlaceholder" class="text-gray-500 text-center py-8">Run a simulation to see detailed analysis and derived physical quantities here.</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Footer -->
    <footer class="mt-8 text-center text-xs text-gray-600" style="font-size: 9pt;">
        <p>
            Q U A N T U M &nbsp; Q &nbsp; P T E &nbsp; L T D
            <span class="mx-2">//</span> U E N &nbsp; 2 0 2 4 3 3 9 9 2 N
            <span class="mx-2">//</span> <a href="mailto:information@quantumq.net" class="text-blue-800 hover:text-indigo-600 cursor-pointer">✉️ E - M A I L</a>
            <span class="mx-2">//</span> <a href="#" id="acknowledgementsLink" class="hover:text-indigo-600 cursor-pointer">ACKNOWLEDGEMENTS</a>
            <span class="mx-2">//</span> <a href="#" id="legalLink" class="hover:text-indigo-600 cursor-pointer">LEGAL</a>
            <span class="mx-2">//</span> 2 0 2 5 &copy;
        </p>
    </footer>

    <!-- Modals (Help, Legal, and AI Interpretation) -->
    <div id="interpretationModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2 class="text-2xl font-bold text-gray-800 mb-4">How to Interpret this Dashboard</h2>

            <h3 class="text-xl font-semibold text-gray-700 mb-2 mt-4">1. The Big Picture: What is this Simulator?</h3>
            <p class="mb-4 text-gray-700">
                This simulator provides a **conceptual visualization** of **3D incompressible fluid dynamics**. It numerically solves a simplified version of the Navier-Stokes equations, which are fundamental to describing how fluids like air and water move. The goal is to help you build an intuition for complex fluid phenomena like turbulence, vortex dynamics, and energy dissipation.
            </p>
            <div class="mt-4 mb-4 text-red-600 font-semibold border border-red-500 p-3 rounded-md">
                <strong class="underline">CRITICAL NOTE FOR RESEARCHERS:</strong> This tool is for educational and conceptual purposes only. It uses a simplified numerical scheme and is **NOT** a high-fidelity Computational Fluid Dynamics (CFD) tool. It **cannot be used to formally prove or disprove the Navier-Stokes existence and smoothness Millennium Prize Problem.** That is a question of pure mathematics concerning the properties of the continuous equations, not numerical approximations.
            </div>

            <h3 class="text-xl font-semibold text-gray-700 mb-2 mt-6">2. Quick Start Guide</h3>
            <ol class="list-decimal list-inside ml-4 text-gray-700 space-y-2">
                <li><b>Set Parameters:</b> Adjust the sliders for Grid Resolution, Viscosity, etc., on the left panel to define your fluid.</li>
                <li><b>(or) Choose a Preset:</b> Click a preset button like "Turbulence" or "Stable Flow" to load a pre-configured scenario.</li>
                <li><b>Run Simulation:</b> Click the main "Simulation" button to start the calculation.</li>
                <li><b>Observe Live:</b> Watch the 3D visualization evolve. You can rotate (left-click), pan (right-click), and zoom (scroll) the view. The live metrics will update on the right.</li>
                <li><b>Stop & Analyze:</b> Once the simulation is complete (or you click "Stop"), the detailed "Analysis" and "Metrics" sections below will become populated with data from the final state of the fluid.</li>
                <li><b>Interpret with AI:</b> If you have a Gemini API key, you can use the "Results", "Ask Einstein", and "Q&A" buttons for an AI-powered analysis of the simulation.</li>
            </ol>

            <h3 class="text-xl font-semibold text-gray-700 mb-2 mt-6">3. The Physics & The Math: A Deep Dive</h3>
            <h4 class="text-lg font-semibold text-gray-600 mb-2 mt-4">The Governing Equations</h4>
            <p class="mb-4 text-gray-700">The core of the simulation is the Navier-Stokes momentum equation for an incompressible fluid:</p>
            <p class="text-center my-4">
                $ \frac{\partial \mathbf{u}}{\partial t} + (\mathbf{u} \cdot \nabla)\mathbf{u} = -\frac{1}{\rho}\nabla p + \nu \nabla^2 \mathbf{u} $
            </p>
            <ul class="list-disc list-inside ml-4 text-gray-700 space-y-2">
                <li>$ \mathbf{u}(x,y,z,t) $ is the fluid velocity vector.</li>
                <li>$ \frac{\partial \mathbf{u}}{\partial t} $ (Unsteady Term): How velocity changes at a point over time.</li>
                <li>$ (\mathbf{u} \cdot \nabla)\mathbf{u} $ (Advection/Convection Term): How the fluid's own motion carries its momentum around. This is a non-linear term and is the source of most of the complexity, including turbulence.</li>
                <li>$ -\frac{1}{\rho}\nabla p $ (Pressure Gradient Term): How differences in pressure ($p$) create forces that push the fluid.</li>
                <li>$ \nu \nabla^2 \mathbf{u} $ (Viscous Diffusion Term): Represents fluid friction, where $\nu$ is the kinematic viscosity. This term smooths out the flow and dissipates energy.</li>
            </ul>
            <p class="mt-4 text-gray-700">This is coupled with the incompressibility condition, which states that mass is conserved (density is constant):</p>
            <p class="text-center my-2">$ \nabla \cdot \mathbf{u} = 0 $</p>

            <h4 class="text-lg font-semibold text-gray-600 mb-2 mt-4">Key Physical Quantities & Metrics</h4>
            <ul class="list-disc list-inside ml-4 text-gray-700 space-y-3">
                <li><b>Vorticity ($\omega$):</b> Defined as the curl of velocity, $ \omega = \nabla \times \mathbf{u} $, vorticity measures the local "spin" or rotation of a fluid parcel. Regions of high vorticity are where the flow is swirling intensely.</li>
                <li><b>Kinetic Energy ($E_k$):</b> The total energy of motion, $ E_k = \frac{1}{2} \int_V |\mathbf{u}|^2 dV $. In a closed system, this energy must be dissipated by viscosity, so it typically decays over time.</li>
                <li><b>Enstrophy ($\mathcal{E}$):</b> The integral of squared vorticity, $ \mathcal{E} = \frac{1}{2} \int_V |\omega|^2 dV $. It represents the rate of energy dissipation due to viscosity. In turbulent flows, enstrophy can increase dramatically through a process called vortex stretching.</li>
                <li><b>Helicity ($\mathcal{H}$):</b> Defined as $ \mathcal{H} = \int_V \mathbf{u} \cdot \omega \, dV $, helicity measures the "knottedness" or alignment of vortex lines with the flow direction.</li>
                <li><b>Reynolds Number ($Re$):</b> The crucial dimensionless ratio of inertial forces to viscous forces, $ Re = \frac{UL}{\nu} $. Low $Re$ flows are smooth and laminar; high $Re$ flows are chaotic and turbulent.</li>
                <li><b>Kolmogorov Length Scale ($\eta$):</b> In turbulence, energy "cascades" from large eddies to small ones. The Kolmogorov scale, $ \eta = (\nu^3 / \epsilon)^{1/4} $ (where $\epsilon$ is the energy dissipation rate), is the smallest length scale in the flow, where viscosity finally dominates and dissipates the energy into heat. A good simulation requires the grid spacing to be smaller than $\eta$.</li>
            </ul>

            <h3 class="text-xl font-semibold text-gray-700 mb-2 mt-6">4. How to Analyze the Plots & Data</h3>
            <h4 class="text-lg font-semibold text-gray-600 mb-2 mt-4">The Kinetic Energy Spectrum</h4>
            <p class="mb-2 text-gray-700">This log-log plot is the most important tool for turbulence analysis. It shows how the fluid's kinetic energy $E$ is distributed across different length scales (represented by wavenumber $k$; small $k$ = large scales, large $k$ = small scales). Look for three distinct regions:</p>
            <ul class="list-disc list-inside ml-4 text-gray-700 space-y-2">
                <li><b>Energy-Containing Range (low $k$):</b> The largest scales where energy is introduced into the flow.</li>
                <li><b>Inertial Range (mid $k$):</b> Energy cascades from large eddies to smaller ones without much dissipation. Here, developed turbulence follows the famous <b>Kolmogorov -5/3 power law</b>, $ E(k) \propto k^{-5/3} $. The dashboard plots a reference line with this slope. If your spectrum matches this slope, you are observing a key feature of turbulence.</li>
                <li><b>Dissipation Range (high $k$):</b> At the smallest scales (near $\eta$), viscosity becomes dominant and dissipates the energy. The spectrum falls off very steeply here.</li>
            </ul>

            <h4 class="text-lg font-semibold text-gray-600 mb-2 mt-4">Distribution Histograms</h4>
            <p class="mb-2 text-gray-700">These plots show the statistical distribution of key quantities at the final simulation time. Long "tails" in the vorticity distribution, for example, are a hallmark of turbulence, indicating the presence of rare but extremely intense vortex structures.</p>

            <h4 class="text-lg font-semibold text-gray-600 mb-2 mt-4">2D & 3D Slice Viewers</h4>
            <p class="mb-2 text-gray-700">These interactive tools allow you to inspect the 3D data. You can select the physical variable (Vorticity, Velocity, Pressure), the axis to slice along (X, Y, Z), and the specific slice index using the shared controls.</p>
            <ul class="list-disc list-inside ml-4 text-gray-700 space-y-2">
                <li><b>2D Slice Viewer:</b> Shows a traditional 2D heatmap and numerical grid of the selected slice. Click any point to open a detailed analysis modal for that specific location.</li>
                <li><b>3D Slice Viewer:</b> Provides two new perspectives. The left view is a full 3D volumetric rendering of the selected variable, allowing you to see the entire structure. The right view is a 3D bar chart of the selected 2D slice, where bar height and color represent the value. Both are fully rotatable.</li>
                <li><b>Multi-Pixel Analysis (in 2D View):</b> Check the "Enable Multi-Pixel Analysis" box. In this mode, you can single-click multiple cells on the numerical grid to add them to a selection. When you are finished, double-click anywhere on the grid. A tooltip will appear showing aggregate statistics for all the points you selected.</li>
            </ul>

            <div id="apiKeyHelpSection">
                <h3 class="text-xl font-semibold text-gray-700 mb-2 mt-6">5. Acquiring a Gemini API Key</h3>
                <p class="mb-4 text-gray-700">To enable the AI-powered interpretation features (Results, Ask Einstein, Q&A), you need a Gemini API key. You can get a free key from Google AI Studio.</p>
                <ol class="list-decimal list-inside ml-4 text-gray-700 space-y-2">
                    <li>Visit the Google AI Studio website: <a href="https://aistudio.google.com/" target="_blank" class="text-blue-600 hover:underline">https://aistudio.google.com/</a></li>
                    <li>Sign in with your Google account.</li>
                    <li>Click the "Get API key" button and create a new API key.</li>
                    <li>Copy the key and paste it into the input box in the "Simulation Metrics" panel.</li>
                </ol>
            </div>

            <div id="acknowledgementsSection">
                <h3 class="text-xl font-semibold text-gray-700 mb-2 mt-6">6. Acknowledgements</h3>
                <p class="mb-4 text-gray-700">This simulator was built using a combination of powerful open-source technologies. We gratefully acknowledge the creators and maintainers of these projects:</p>
                <ul class="list-disc list-inside ml-4 text-gray-700 space-y-3">
                    <li><b>HTML5, CSS3, & JavaScript (ES6+):</b> The fundamental technologies of the web.</li>
                    <li><b>Tailwind CSS:</b> For rapid UI development. (<a href="https://opensource.org/licenses/MIT" target="_blank" class="text-blue-600">MIT License</a>)</li>
                    <li><b>Three.js:</b> For 3D rendering. (<a href="https://github.com/mrdoob/three.js/blob/dev/LICENSE" target="_blank" class="text-blue-600">MIT License</a>)</li>
                    <li><b>Chart.js:</b> For all data visualizations. (<a href="https://opensource.org/licenses/MIT" target="_blank" class="text-blue-600">MIT License</a>)</li>
                    <li><b>MathJax:</b> For beautiful LaTeX rendering. (<a href="https://www.apache.org/licenses/LICENSE-2.0" target="_blank" class="text-blue-600">Apache License 2.0</a>)</li>
                    <li><b>Google Gemini:</b> The advanced LLM that powers the AI-driven interpretation features.</li>
                </ul>
            </div>
        </div>
    </div>

    <div id="legalModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Legal Disclaimers & Terms of Use</h2>
            
            <h3 class="text-lg font-semibold text-gray-700 mb-2">1. Experimental Research Tool</h3>
            <p class="mb-4 text-gray-700 text-sm">
                This 3D Fluid Dynamics Simulator (the "Tool") is provided by Quantum Q PTE. LTD. ("Quantum Q") as an experimental research and educational tool, currently in a beta development phase. It is intended solely for use by the scientific, mathematical, and engineering communities for conceptual exploration and educational purposes. The Tool is not designed, certified, or intended for use in any commercial, industrial, clinical, or mission-critical applications.
            </p>

            <h3 class="text-lg font-semibold text-gray-700 mb-2">2. No Warranty</h3>
            <p class="mb-4 text-gray-700 text-sm">
                THE TOOL IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT. IN NO EVENT SHALL QUANTUM Q, ITS DIRECTORS, EMPLOYEES, OR AFFILIATES BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT, OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH THE TOOL OR THE USE OR OTHER DEALINGS IN THE TOOL.
            </p>

            <h3 class="text-lg font-semibold text-gray-700 mb-2">3. Limitation of Liability & Risk Assumption</h3>
            <p class="mb-4 text-gray-700 text-sm">
                You expressly understand and agree that Quantum Q, its directors, and its employees shall not be liable for any direct, indirect, incidental, special, consequential, or exemplary damages, including but not limited to, damages for loss of profits, goodwill, use, data, or other intangible losses (even if Quantum Q has been advised of the possibility of such damages), resulting from the use or the inability to use the Tool. The entire risk as to the quality, performance, and accuracy of the Tool is with you. This includes, but is not limited to, any damages or injury caused by any failure of performance, error, omission, interruption, defect, or bug within the software, particularly given its acknowledged experimental and beta status. Should the Tool prove defective, you assume the entire cost of all necessary servicing, repair, or correction, and you agree to indemnify and hold harmless Quantum Q and its employees from any and all claims arising from your use of the Tool.
            </p>

            <h3 class="text-lg font-semibold text-gray-700 mb-2">4. No Guarantee of Accuracy</h3>
            <p class="mb-4 text-gray-700 text-sm">
                While efforts have been made to ensure the mathematical and numerical integrity of the simulation, Quantum Q makes no guarantee as to the accuracy, reliability, or completeness of the results generated by the Tool. The outputs are for illustrative and conceptual purposes only and should not be used for peer-reviewed publications, engineering design, or any other formal application without independent verification and validation. As stated prominently within the Tool, this simulator is an *analogue* and is not a direct simulation of the 3D Navier-Stokes equations.
            </p>

            <h3 class="text-lg font-semibold text-gray-700 mb-2">5. Intellectual Property</h3>
            <p class="mb-4 text-gray-700 text-sm">
                All rights, title, and interest in and to the Tool, including its source code, design, and branding, are the exclusive property of Quantum Q PTE. LTD. You may not copy, modify, distribute, sell, or lease any part of our Tool or its included software, nor may you reverse engineer or attempt to extract the source code of that software, unless laws prohibit those restrictions or you have our written permission.
            </p>

            <h3 class="text-lg font-semibold text-gray-700 mb-2">6. Governing Law & Jurisdiction</h3>
            <p class="mb-4 text-gray-700 text-sm">
                These terms shall be governed by and construed in accordance with the laws of the Republic of Singapore, without regard to its conflict of law provisions. Any disputes arising out of or in connection with these terms shall be subject to the exclusive jurisdiction of the courts of the Republic of Singapore.
            </p>
            
            <h3 class="text-lg font-semibold text-gray-700 mb-2">7. International Applicability and English Law</h3>
            <p class="mb-4 text-gray-700 text-sm">
                While the primary governing law is that of the Republic of Singapore, these terms are intended to be broadly applicable to users globally. For users in jurisdictions where English law is applicable or preferred, these terms shall be interpreted in a manner consistent with the general principles of English contract law, to the extent that such interpretation does not conflict with the mandatory laws of Singapore. The parties acknowledge and agree that the principles of common law and equity, as applied in English law, may be considered in interpreting these terms where Singapore law is silent or where such principles provide additional clarity, provided always that Singapore law remains the ultimate governing law.
            </p>

            <p class="text-gray-600 text-xs italic mt-6">By using this Tool, you acknowledge that you have read, understood, and agree to be bound by these terms and disclaimers.</p>
        </div>
    </div>

    <div id="aiInterpretationModal" class="modal">
        <div class="modal-content w-11/12 md:w-3/4 lg:w-1/2">
            <span class="close-button" id="closeAiInterpretationModal">&times;</span>
            <h2 class="text-2xl font-bold text-gray-800 mb-4">✨ AI Simulation Interpretation</h2>
            <div id="aiInterpretationContent" class="text-gray-700 prose max-w-none">
                <div class="flex justify-center items-center py-8">
                    <span class="spinner w-8 h-8 !border-t-purple-500 !border-gray-200"></span>
                    <span id="aiProgressMessage" class="ml-2 text-gray-600">Generating...</span>
                </div>
            </div>
            <p class="text-sm text-gray-500 mt-4 italic">
                (Interpretation provided by Gemini LLM. It is for conceptual understanding and does not constitute formal scientific analysis.)
            </p>
        </div>
    </div>
    
    <div id="mathDetailModal" class="modal">
        <div class="modal-content w-11/12 max-w-[824px]">
            <span class="close-button">&times;</span>
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Detailed Analysis at Point (<span id="mathDetailCoords"></span>)</h2>
            <div id="mathDetailContent" class="text-gray-700 prose max-w-none text-sm">
                <!-- Content will be generated by JS -->
            </div>
            <p class="text-xs text-gray-500 mt-4 italic">
                (Gradients are calculated using a second-order central difference scheme.)
            </p>
        </div>
    </div>

    <!-- Dynamic Tooltip Element (Hidden by default) -->
    <div id="dynamicTooltip" class="absolute z-50 p-2 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 transition-opacity duration-200 pointer-events-none"></div>
    
    <script type="importmap">
    {
      "imports": {
        "@google/generative-ai": "https://esm.sh/@google/generative-ai@0.14.0"
      }
    }
    </script>

    <script type="module">
        import { GoogleGenerativeAI } from "@google/generative-ai";

        // ==============================================================================
        // UTILITY: 3D FAST FOURIER TRANSFORM
        // ==============================================================================
        const FFT = {
            complex: {
                add: (a, b) => [a[0] + b[0], a[1] + b[1]],
                sub: (a, b) => [a[0] - b[0], a[1] - b[1]],
                mul: (a, b) => [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]],
                exp: (phi) => [Math.cos(phi), Math.sin(phi)],
                abs: (a) => Math.sqrt(a[0] * a[0] + a[1] * a[1]),
            },
            
            _fft: function(x, inverse = false) {
                const N = x.length;
                if (N <= 1) return x;
                const even = this._fft(x.filter((_, i) => i % 2 === 0), inverse);
                const odd = this._fft(x.filter((_, i) => i % 2 === 1), inverse);
                const result = new Array(N);
                const sign = inverse ? 1 : -1;
                for (let k = 0; k < N / 2; k++) {
                    const t = this.complex.mul(this.complex.exp(sign * 2 * Math.PI * k / N), odd[k]);
                    result[k] = this.complex.add(even[k], t);
                    result[k + N / 2] = this.complex.sub(even[k], t);
                }
                return result;
            },

            fft3d: function(matrix, N, inverse = false) {
                let tempMatrix = Array(N).fill(0).map(() => Array(N).fill(0).map(() => Array(N).fill([0,0])));

                // FFT along Z
                for (let i = 0; i < N; i++) {
                    for (let j = 0; j < N; j++) {
                        let col = [];
                        for (let l = 0; l < N; l++) col.push(matrix[i][j][l]);
                        let fftCol = this._fft(col, inverse);
                        for (let l = 0; l < N; l++) tempMatrix[i][j][l] = fftCol[l];
                    }
                }
                // FFT along Y
                for (let i = 0; i < N; i++) {
                    for (let l = 0; l < N; l++) {
                        let row = [];
                        for (let j = 0; j < N; j++) row.push(tempMatrix[i][j][l]);
                        let fftRow = this._fft(row, inverse);
                        for (let j = 0; j < N; j++) matrix[i][j][l] = fftRow[j];
                    }
                }
                // FFT along X
                for (let j = 0; j < N; j++) {
                    for (let l = 0; l < N; l++) {
                        let depth = [];
                        for (let i = 0; i < N; i++) depth.push(matrix[i][j][l]);
                        let fftDepth = this._fft(depth, inverse);
                        for (let i = 0; i < N; i++) tempMatrix[i][j][l] = fftDepth[i];
                    }
                }
                if (inverse) {
                    const N3 = N * N * N;
                    for (let i = 0; i < N; i++) for (let j = 0; j < N; j++) for (let l = 0; l < N; l++) {
                        tempMatrix[i][j][l][0] /= N3; tempMatrix[i][j][l][1] /= N3;
                    }
                }
                return tempMatrix;
            }
        };

        // ==============================================================================
        // CLASS 1: THE 3D FLUID SIMULATION ENGINE
        // ==============================================================================
        class FluidSimulator3D {
            constructor(N, viscosity, dt) {
                this.N = N;
                this.size = N + 2;
                this.viscosity = viscosity;
                this.dt = dt;
                this.dx = 1.0 / N;

                this.u = this.create3DArray(); this.v = this.create3DArray(); this.w = this.create3DArray();
                this.u_prev = this.create3DArray(); this.v_prev = this.create3DArray(); this.w_prev = this.create3DArray();
                this.density = this.create3DArray(); this.density_prev = this.create3DArray();
                this.p = this.create3DArray(); this.div = this.create3DArray();
            }

            create3DArray() { return Array(this.size).fill(0).map(() => Array(this.size).fill(0).map(() => new Float32Array(this.size).fill(0))); }

            set_bnd(b, x) {
                for (let i = 1; i <= this.N; i++) {
                    for (let j = 1; j <= this.N; j++) {
                        x[0][i][j] = b == 1 ? -x[1][i][j] : x[1][i][j];
                        x[this.N + 1][i][j] = b == 1 ? -x[this.N][i][j] : x[this.N][i][j];
                        x[i][0][j] = b == 2 ? -x[i][1][j] : x[i][1][j];
                        x[i][this.N + 1][j] = b == 2 ? -x[i][this.N][j] : x[i][this.N][j];
                        x[i][j][0] = b == 3 ? -x[i][j][1] : x[i][j][1];
                        x[i][j][this.N + 1] = b == 3 ? -x[i][j][this.N] : x[i][j][this.N];
                    }
                }
                x[0][0][0] = 0.33 * (x[1][0][0] + x[0][1][0] + x[0][0][1]);
                x[0][this.N + 1][0] = 0.33 * (x[1][this.N + 1][0] + x[0][this.N][0] + x[0][this.N + 1][1]);
                x[this.N + 1][0][0] = 0.33 * (x[this.N][0][0] + x[this.N + 1][1][0] + x[this.N + 1][0][1]);
                x[this.N + 1][this.N + 1][0] = 0.33 * (x[this.N][this.N + 1][0] + x[this.N + 1][this.N][0] + x[this.N + 1][this.N + 1][1]);
                x[0][0][this.N + 1] = 0.33 * (x[1][0][this.N + 1] + x[0][1][this.N + 1] + x[0][0][this.N]);
                x[0][this.N + 1][this.N + 1] = 0.33 * (x[1][this.N + 1][this.N + 1] + x[0][this.N][this.N + 1] + x[0][this.N + 1][this.N]);
                x[this.N + 1][0][this.N + 1] = 0.33 * (x[this.N][0][this.N + 1] + x[this.N + 1][1][this.N + 1] + x[this.N + 1][0][this.N]);
                x[this.N + 1][this.N + 1][this.N + 1] = 0.33 * (x[this.N][this.N + 1][this.N + 1] + x[this.N + 1][this.N][this.N + 1] + x[this.N + 1][this.N + 1][this.N]);
            }
            
            lin_solve(b, x, x0, a, c) {
                const cRecip = 1.0 / c;
                for (let k = 0; k < 20; k++) {
                    for (let l = 1; l <= this.N; l++) {
                        for (let j = 1; j <= this.N; j++) {
                            for (let i = 1; i <= this.N; i++) {
                                x[i][j][l] = (x0[i][j][l] + a * (x[i - 1][j][l] + x[i + 1][j][l] + x[i][j - 1][l] + x[i][j + 1][l] + x[i][j][l - 1] + x[i][j][l + 1])) * cRecip;
                            }
                        }
                    }
                    this.set_bnd(b, x);
                }
            }

            diffuse(b, x, x0, diff) {
                const a = this.dt * diff * this.N * this.N;
                this.lin_solve(b, x, x0, a, 1 + 6 * a);
            }

            advect(b, d, d0, u, v, w) {
                const dt0 = this.dt * this.N;
                for (let l = 1; l <= this.N; l++) { for (let j = 1; j <= this.N; j++) { for (let i = 1; i <= this.N; i++) {
                    let x = i - dt0 * u[i][j][l]; let y = j - dt0 * v[i][j][l]; let z = l - dt0 * w[i][j][l];
                    if (x < 0.5) x = 0.5; if (x > this.N + 0.5) x = this.N + 0.5; let i0 = Math.floor(x); let i1 = i0 + 1;
                    if (y < 0.5) y = 0.5; if (y > this.N + 0.5) y = this.N + 0.5; let j0 = Math.floor(y); let j1 = j0 + 1;
                    if (z < 0.5) z = 0.5; if (z > this.N + 0.5) z = this.N + 0.5; let l0 = Math.floor(z); let l1 = l0 + 1;
                    let s1 = x - i0; let s0 = 1 - s1; let t1 = y - j0; let t0 = 1 - t1; let r1 = z - l0; let r0 = 1 - r1;
                    d[i][j][l] = s0 * (t0 * r0 * d0[i0][j0][l0] + t1 * r0 * d0[i0][j1][l0] + t0 * r1 * d0[i0][j0][l1] + t1 * r1 * d0[i0][j1][l1]) +
                                 s1 * (t0 * r0 * d0[i1][j0][l0] + t1 * r0 * d0[i1][j1][l0] + t0 * r1 * d0[i1][j0][l1] + t1 * r1 * d0[i1][j1][l1]);
                }}}
                this.set_bnd(b, d);
            }
            
            project() {
                const h = 1.0 / this.N;
                for (let l = 1; l <= this.N; l++) { for (let j = 1; j <= this.N; j++) { for (let i = 1; i <= this.N; i++) {
                    this.div[i][j][l] = -0.5 * h * (this.u[i+1][j][l] - this.u[i-1][j][l] + this.v[i][j+1][l] - this.v[i][j-1][l] + this.w[i][j][l+1] - this.w[i][j][l-1]);
                    this.p[i][j][l] = 0;
                }}}
                this.set_bnd(0, this.div); this.set_bnd(0, this.p);
                this.lin_solve(0, this.p, this.div, 1, 6);
                for (let l = 1; l <= this.N; l++) { for (let j = 1; j <= this.N; j++) { for (let i = 1; i <= this.N; i++) {
                    this.u[i][j][l] -= 0.5 * (this.p[i+1][j][l] - this.p[i-1][j][l]) / h;
                    this.v[i][j][l] -= 0.5 * (this.p[i][j+1][l] - this.p[i][j-1][l]) / h;
                    this.w[i][j][l] -= 0.5 * (this.p[i][j][l+1] - this.p[i][j][l-1]) / h;
                }}}
                this.set_bnd(1, this.u); this.set_bnd(2, this.v); this.set_bnd(3, this.w);
            }

            fluid_step() {
                [this.u_prev, this.u] = [this.u, this.u_prev]; [this.v_prev, this.v] = [this.v, this.v_prev]; [this.w_prev, this.w] = [this.w, this.w_prev];
                this.diffuse(1, this.u, this.u_prev, this.viscosity);
                this.diffuse(2, this.v, this.v_prev, this.viscosity);
                this.diffuse(3, this.w, this.w_prev, this.viscosity);
                this.project();
                [this.u_prev, this.u] = [this.u, this.u_prev]; [this.v_prev, this.v] = [this.v, this.v_prev]; [this.w_prev, this.w] = [this.w, this.w_prev];
                this.advect(1, this.u, this.u_prev, this.u_prev, this.v_prev, this.w_prev);
                this.advect(2, this.v, this.v_prev, this.u_prev, this.v_prev, this.w_prev);
                this.advect(3, this.w, this.w_prev, this.u_prev, this.v_prev, this.w_prev);
                this.project();
                [this.density_prev, this.density] = [this.density, this.density_prev];
                this.diffuse(0, this.density, this.density_prev, 0);
                [this.density_prev, this.density] = [this.density, this.density_prev];
                this.advect(0, this.density, this.density_prev, this.u, this.v, this.w);
            }
            
            calculateVorticity(source = this) {
                const omegaX = this.create3DArray(); const omegaY = this.create3DArray(); const omegaZ = this.create3DArray();
                const h2 = 2 * this.dx;
                for (let i = 1; i <= this.N; i++) for (let j = 1; j <= this.N; j++) for (let l = 1; l <= this.N; l++) {
                    const dWdY = (source.w[i][j+1][l] - source.w[i][j-1][l]) / h2;
                    const dVdZ = (source.v[i][j][l+1] - source.v[i][j][l-1]) / h2;
                    omegaX[i][j][l] = dWdY - dVdZ;
                    const dUdZ = (source.u[i][j][l+1] - source.u[i][j][l-1]) / h2;
                    const dWdX = (source.w[i+1][j][l] - source.w[i-1][j][l]) / h2;
                    omegaY[i][j][l] = dUdZ - dWdX;
                    const dVdX = (source.v[i+1][j][l] - source.v[i-1][j][l]) / h2;
                    const dUdY = (source.u[i][j+1][l] - source.u[i][j-1][l]) / h2;
                    omegaZ[i][j][l] = dVdX - dUdY;
                }
                return { omegaX, omegaY, omegaZ };
            }

            calculateVorticityMagnitude(vorticity) {
                const vorticityMag = this.create3DArray();
                 for (let i = 1; i <= this.N; i++) for (let j = 1; j <= this.N; j++) for (let l = 1; l <= this.N; l++) {
                    vorticityMag[i][j][l] = Math.sqrt(vorticity.omegaX[i][j][l]**2 + vorticity.omegaY[i][j][l]**2 + vorticity.omegaZ[i][j][l]**2);
                 }
                 return vorticityMag;
            }

            calculateHelicity(vorticity, source = this) {
                let helicity = 0;
                for (let i = 1; i <= this.N; i++) for (let j = 1; j <= this.N; j++) for (let l = 1; l <= this.N; l++) {
                    helicity += source.u[i][j][l] * vorticity.omegaX[i][j][l] +
                                source.v[i][j][l] * vorticity.omegaY[i][j][l] +
                                source.w[i][j][l] * vorticity.omegaZ[i][j][l];
                }
                return helicity / (this.N**3);
            }

            calculateMetric(metricFunc) {
                let total = 0;
                for (let i = 1; i <= this.N; i++) for (let j = 1; j <= this.N; j++) for (let l = 1; l <= this.N; l++) {
                    total += metricFunc(i, j, l);
                }
                return total / (this.N * this.N * this.N);
            }

            getDistribution(dataSourceFunc, numBins = 20, range = null) {
                const values = [];
                for (let i = 1; i <= this.N; i++) for (let j = 1; j <= this.N; j++) for (let l = 1; l <= this.N; l++) {
                    values.push(dataSourceFunc(i, j, l));
                }
                if (values.length === 0) return { labels: [], data: [] };
                
                let minVal, maxVal;
                if (range) {
                    [minVal, maxVal] = range;
                } else {
                    minVal = values[0]; maxVal = values[0];
                    for(let i = 1; i < values.length; i++) {
                        if(values[i] < minVal) minVal = values[i];
                        if(values[i] > maxVal) maxVal = values[i];
                    }
                }

                if (maxVal === minVal) return { labels: [maxVal.toPrecision(2)], data: [values.length] };
                
                const binWidth = (maxVal - minVal) / numBins;
                const histData = new Array(numBins).fill(0);
                const labels = Array.from({length: numBins}, (_, i) => {
                     const binStart = minVal + i * binWidth;
                     return `${binStart.toPrecision(2)}`;
                });
                
                values.forEach(val => {
                    let binIndex = Math.floor((val - minVal) / binWidth);
                    if (binIndex >= numBins) binIndex = numBins - 1;
                    if (binIndex < 0) binIndex = 0;
                    histData[binIndex]++;
                });
                return { labels, data: histData };
            }
        }

        // ==============================================================================
        // CLASS 2: THE INTERACTIVE DASHBOARD
        // ==============================================================================
        class SimulationDashboard {
            constructor() {
                this.simulator = null; this.renderer = null; this.scene = null; this.camera = null; this.controls = null;
                this.animationFrameId = null; this.isSimulationRunning = false; this.isSimulationPaused = false; this.isSimulationFinished = false;
                this.currentSimStep = 0; this.totalSimSteps = 0;
                this.visualizationMode = 'velocity';
                this.geminiApiKey = "";
                this.tooltipsEnabled = false;

                this.finalStateSnapshot = null;
                this.simulationSnapshots = [];
                this.simulationTimeSteps = [];
                this.lastHighlightedCell = null;
                this.selectedCellElement = null;
                this.currentSliceData = { data: null, min: 0, max: 0, variable: '', axis: '', index: 0 };
                this.selectedPoint = { i: null, j: null, k: null, gridX: null, gridY: null };
                this.isMultiSelectMode = false;
                this.selectedPixels = [];
                this.sliceAnimationTimer = null;
                this.replayAnimationTimer = null;

                this.velocityArrows = new THREE.Group(); this.densitySpheres = new THREE.Group(); this.vorticitySpheres = new THREE.Group();
                
                this.metricsHistory = { ke: [], enstrophy: [], helicity: [], maxVort: [], time: [] };
                this.maxMetrics = { ke: 0, enstrophy: 0, helicity: 0, maxVel: 0, maxVort: 0 };
                this.charts = {};
                
                // 3D Slice Viewer properties
                this.scene3DSlice = null; this.camera3DSlice = null; this.renderer3DSlice = null; this.controls3DSlice = null;
                this.scene3DGrid = null; this.camera3DGrid = null; this.renderer3DGrid = null; this.controls3DGrid = null;
                this.volumeVoxels = new THREE.Group(); this.gridBars = new THREE.Group();


                this.elements = {
                    paramGridSize: document.getElementById('paramGridSize'), inputGridSize: document.getElementById('inputGridSize'),
                    paramViscosity: document.getElementById('paramViscosity'), inputViscosity: document.getElementById('inputViscosity'),
                    paramDt: document.getElementById('paramDt'), inputDt: document.getElementById('inputDt'),
                    paramSimTime: document.getElementById('paramSimTime'), inputSimTime: document.getElementById('inputSimTime'),
                    paramInitCondition: document.getElementById('paramInitCondition'), paramVisualization: document.getElementById('paramVisualization'),
                    btnRun: document.getElementById('btnRun'), btnRunContent: document.getElementById('btnRunContent'), btnPauseResume: document.getElementById('btnPauseResume'),
                    btnRefresh: document.getElementById('btnRefresh'), btnExport: document.getElementById('btnExport'), btnHelp: document.getElementById('btnHelp'),
                    btnResults: document.getElementById('btnResults'), btnInterpretKids: document.getElementById('btnInterpretKids'), btnQA: document.getElementById('btnQA'), btnConversation: document.getElementById('btnConversation'), navierStokesAudio: document.getElementById('navierStokesAudio'),
                    geminiApiKeyInput: document.getElementById('geminiApiKeyInput'),
                    getApiKeyLink: document.getElementById('getApiKeyLink'),
                    progressBar: document.getElementById('progressBar'), threeJsContainer: document.getElementById('threeJsContainer'), performanceWarning: document.getElementById('performanceWarning'),
                    interpretationModal: document.getElementById('interpretationModal'), legalModal: document.getElementById('legalModal'), aiInterpretationModal: document.getElementById('aiInterpretationModal'), mathDetailModal: document.getElementById('mathDetailModal'),
                    closeModalButtons: document.querySelectorAll('.modal .close-button'), aiInterpretationContent: document.getElementById('aiInterpretationContent'),
                    mathDetailCoords: document.getElementById('mathDetailCoords'), mathDetailContent: document.getElementById('mathDetailContent'),
                    legalLink: document.getElementById('legalLink'), acknowledgementsLink: document.getElementById('acknowledgementsLink'),
                    metricKE_current: document.getElementById('metricKE_current'), metricKE_max: document.getElementById('metricKE_max'),
                    metricEnstrophy_current: document.getElementById('metricEnstrophy_current'), metricEnstrophy_max: document.getElementById('metricEnstrophy_max'),
                    metricHelicity_current: document.getElementById('metricHelicity_current'), metricHelicity_max: document.getElementById('metricHelicity_max'),
                    metricMaxVel_current: document.getElementById('metricMaxVel_current'), metricMaxVel_max: document.getElementById('metricMaxVel_max'),
                    metricMaxVort_current: document.getElementById('metricMaxVort_current'), metricMaxVort_max: document.getElementById('metricMaxVort_max'),
                    metricAvgDiv_current: document.getElementById('metricAvgDiv_current'),
                    keChartCanvas: document.getElementById('keChartCanvas'), enstrophyChartCanvas: document.getElementById('enstrophyChartCanvas'), helicityChartCanvas: document.getElementById('helicityChartCanvas'), maxVortChartCanvas: document.getElementById('maxVortChartCanvas'),
                    velocityDistChartCanvas: document.getElementById('velocityDistChartCanvas'), vorticityDistChartCanvas: document.getElementById('vorticityDistChartCanvas'), pressureDistChartCanvas: document.getElementById('pressureDistChartCanvas'), helicityCosineDistChartCanvas: document.getElementById('helicityCosineDistChartCanvas'),
                    energySpectrumChartCanvas: document.getElementById('energySpectrumChartCanvas'),
                    presetStableFlow: document.getElementById('presetStableFlow'), presetTurbulence: document.getElementById('presetTurbulence'), presetVortexStretching: document.getElementById('presetVortexStretching'), presetDensityTransport: document.getElementById('presetDensityTransport'),
                    simulationActivityIndicator: document.getElementById('simulationActivityIndicator'), percentageCounter: document.getElementById('percentageCounter'), liveSimSubtitle: document.getElementById('liveSimSubtitle'),
                    enableTooltips: document.getElementById('enableTooltips'), dynamicTooltip: document.getElementById('dynamicTooltip'), mainContentArea: document.getElementById('mainContentArea'),
                    tabDistribution: document.getElementById('tabDistribution'), tabSpectrum: document.getElementById('tabSpectrum'), tabSlicing: document.getElementById('tabSlicing'), tabSlicing3D: document.getElementById('tabSlicing3D'),
                    distributionContent: document.getElementById('distributionContent'), spectrumContent: document.getElementById('spectrumContent'), slicingContent: document.getElementById('slicingContent'), slicingContent3D: document.getElementById('slicingContent3D'),
                    analysisPlaceholderWrapper: document.getElementById('analysisPlaceholderWrapper'), analysisPlaceholder: document.getElementById('analysisPlaceholder'),
                    derivedMetricsWrapper: document.getElementById('derivedMetricsWrapper'),
                    metricRe: document.getElementById('metricRe'), metricReTaylor: document.getElementById('metricReTaylor'), metricEpsilon: document.getElementById('metricEpsilon'),
                    metricEta: document.getElementById('metricEta'), metricLInt: document.getElementById('metricLInt'), metricDxEtaRatio: document.getElementById('metricDxEtaRatio'),
                    playbackControls: document.getElementById('playbackControls'), playbackSlider: document.getElementById('playbackSlider'),
                    playbackCurrentTime: document.getElementById('playbackCurrentTime'), playbackTotalTime: document.getElementById('playbackTotalTime'),
                    btnReplay: document.getElementById('btnReplay'),
                    replayPlayIcon: document.getElementById('replayPlayIcon'),
                    replayPauseIcon: document.getElementById('replayPauseIcon'),
                    sliceControlsContainer: document.getElementById('sliceControlsContainer'),
                    sliceCanvas: document.getElementById('sliceCanvas'), sliceColorbarCanvas: document.getElementById('sliceColorbarCanvas'),
                    sliceVariableSelect: document.getElementById('sliceVariableSelect'), sliceAxisSelect: document.getElementById('sliceAxisSelect'),
                    sliceIndexSlider: document.getElementById('sliceIndexSlider'), sliceIndexLabel: document.getElementById('sliceIndexLabel'),
                    sliceColorbarMin: document.getElementById('sliceColorbarMin'), sliceColorbarMax: document.getElementById('sliceColorbarMax'),
                    sliceGridContainer: document.getElementById('sliceGridContainer'),
                    sliceValueSymbol: document.getElementById('sliceValueSymbol'),
                    sliceLiveValue: document.getElementById('sliceLiveValue'),
                    multiSelectCheckbox: document.getElementById('multiSelectCheckbox'),
                    multiSelectActiveMessage: document.getElementById('multiSelectActiveMessage'),
                    threeJsSliceContainer: document.getElementById('threeJsSliceContainer'),
                    threeJsGridContainer: document.getElementById('threeJsGridContainer'),
                    volumeColorbarCanvas: document.getElementById('volumeColorbarCanvas'),
                    volumeColorbarMin: document.getElementById('volumeColorbarMin'),
                    volumeColorbarMax: document.getElementById('volumeColorbarMax'),
                    gridColorbarCanvas: document.getElementById('gridColorbarCanvas'),
                    gridColorbarMin: document.getElementById('gridColorbarMin'),
                    gridColorbarMax: document.getElementById('gridColorbarMax'),
                    btnSlicePlayPause: document.getElementById('btnSlicePlayPause'),
                    slicePlayIcon: document.getElementById('slicePlayIcon'),
                    slicePauseIcon: document.getElementById('slicePauseIcon'),
                };
                
                this.presetButtons = [
                    this.elements.presetStableFlow, this.elements.presetTurbulence,
                    this.elements.presetVortexStretching, this.elements.presetDensityTransport
                ];
                this.parameterControls = [
                    this.elements.paramGridSize, this.elements.inputGridSize,
                    this.elements.paramViscosity, this.elements.inputViscosity,
                    this.elements.paramDt, this.elements.inputDt,
                    this.elements.paramSimTime, this.elements.inputSimTime,
                    this.elements.paramInitCondition, this.elements.paramVisualization
                ];

                this._boundHandleTooltipShow = this.handleTooltipShow.bind(this);
                this._boundHandleTooltipHide = this.handleTooltipHide.bind(this);
                this._boundHandleSliceHover = this.handleSliceHover.bind(this);
                this._boundHandleSliceLeave = this.handleSliceLeave.bind(this);
                this._boundHandleGridHover = this.handleGridHover.bind(this);
                this._boundHandleGridLeave = this.handleGridLeave.bind(this);
                this._boundHandleSliceClick = this.handleSliceClick.bind(this);
                this._boundHandleGridClick = this.handleGridClick.bind(this);
                this._boundHandleGridDoubleClick = this.handleGridDoubleClick.bind(this);
                
                this.setupEventListeners();
                this.updateAllSliderTrackColors();
                this.initThreeJs();
                this.init3DSliceViewers();
                this.setupAnimationLoop();
                this.refreshApplication();
            }

            setupSync(sliderId, inputId, fixedPoints = 0) {
                const slider = this.elements[sliderId];
                const input = this.elements[inputId];
                slider.oninput = () => {
                    input.value = parseFloat(slider.value).toFixed(fixedPoints);
                    this.updateSliderTrackColor(slider);
                };
                input.onchange = () => {
                    let value = parseFloat(input.value);
                    const min = parseFloat(slider.min);
                    const max = parseFloat(slider.max);
                    if (isNaN(value)) value = min;
                    value = Math.max(min, Math.min(max, value));
                    slider.value = value;
                    input.value = value.toFixed(fixedPoints);
                    this.updateSliderTrackColor(slider);
                };
            }

            updateSliderTrackColor(sliderElement) {
                if (!sliderElement) return;
                const value = parseFloat(sliderElement.value);
                const min = parseFloat(sliderElement.min);
                const max = parseFloat(sliderElement.max);
                const percentage = ((value - min) / (max - min)) * 100;
                sliderElement.style.setProperty('--slider-value-percent', `${percentage}%`);
            }
            
            updateAllSliderTrackColors() {
                this.updateSliderTrackColor(this.elements.paramGridSize);
                this.updateSliderTrackColor(this.elements.paramViscosity);
                this.updateSliderTrackColor(this.elements.paramDt);
                this.updateSliderTrackColor(this.elements.paramSimTime);
                this.updateSliderTrackColor(this.elements.playbackSlider);
                this.updateSliderTrackColor(this.elements.sliceIndexSlider);
            }

            setupEventListeners() {
                this.setupSync('paramGridSize', 'inputGridSize', 0);
                this.setupSync('paramViscosity', 'inputViscosity', 3);
                this.setupSync('paramDt', 'inputDt', 3);
                this.setupSync('paramSimTime', 'inputSimTime', 0);
                
                this.elements.paramVisualization.onchange = () => { this.visualizationMode = this.elements.paramVisualization.value; this.update3DVisualization(); };
                
                this.elements.btnRun.onclick = () => this.handleRunStop();
                this.elements.btnPauseResume.onclick = () => this.handlePauseResume();
                this.elements.btnRefresh.onclick = () => this.refreshApplication();
                this.elements.btnExport.onclick = () => this.exportData();
                this.elements.btnHelp.onclick = () => this.showModal('interpretationModal');
                this.elements.legalLink.onclick = (e) => { e.preventDefault(); this.showModal('legalModal'); };
                this.elements.acknowledgementsLink.onclick = (e) => { e.preventDefault(); this.showModal('interpretationModal', 'acknowledgementsSection'); };
                this.elements.getApiKeyLink.onclick = (e) => { e.preventDefault(); this.showModal('interpretationModal', 'apiKeyHelpSection'); };
                this.elements.closeModalButtons.forEach(btn => btn.onclick = () => this.hideAllModals());
                window.onclick = (event) => { if (event.target.classList.contains('modal')) this.hideAllModals(); };
                window.onresize = () => this.onWindowResize();
                
                this.elements.presetStableFlow.onclick = () => this.applyPreset({ gridSize: 16, viscosity: 0.08, dt: 0.01, simTime: 1000, initCondition: 'vortex', visualization: 'velocity' });
                this.elements.presetTurbulence.onclick = () => this.applyPreset({ gridSize: 24, viscosity: 0.005, dt: 0.01, simTime: 1500, initCondition: 'random', visualization: 'vorticity' });
                this.elements.presetVortexStretching.onclick = () => this.applyPreset({ gridSize: 20, viscosity: 0.01, dt: 0.01, simTime: 700, initCondition: 'vortex', visualization: 'velocity' });
                this.elements.presetDensityTransport.onclick = () => this.applyPreset({ gridSize: 16, viscosity: 0.02, dt: 0.01, simTime: 800, initCondition: 'jet', visualization: 'density' });

                this.elements.btnResults.onclick = () => this.interpretSimulationState('expert');
                this.elements.btnInterpretKids.onclick = () => this.interpretSimulationState('kids');
                this.elements.btnQA.onclick = () => this.interpretSimulationState('qa');
                this.elements.btnConversation.onclick = () => this.playConversationAudio();
                
                this.elements.enableTooltips.onchange = (e) => { this.tooltipsEnabled = e.target.checked; if(!this.tooltipsEnabled) this.handleTooltipHide(); };
                this.elements.mainContentArea.addEventListener('mouseover', this._boundHandleTooltipShow);
                this.elements.mainContentArea.addEventListener('mouseout', this._boundHandleTooltipHide);
                this.elements.mainContentArea.addEventListener('mousemove', this._boundHandleTooltipShow);


                this.elements.geminiApiKeyInput.oninput = () => this.validateAndSetApiKey();
                
                this.elements.playbackSlider.oninput = () => this.handlePlaybackScrub();
                this.elements.btnReplay.onclick = () => this.toggleReplayAnimation();

                // New event listeners for analysis tabs and slice controls
                [this.elements.tabDistribution, this.elements.tabSpectrum, this.elements.tabSlicing, this.elements.tabSlicing3D].forEach(tab => {
                    tab.onclick = (e) => this.switchTab(e.currentTarget);
                });
                
                this.elements.sliceVariableSelect.onchange = () => this.drawCurrentSlice();
                this.elements.sliceAxisSelect.onchange = () => this.drawCurrentSlice();
                this.elements.sliceIndexSlider.oninput = () => {
                    this.elements.sliceIndexLabel.textContent = this.elements.sliceIndexSlider.value;
                    this.updateSliderTrackColor(this.elements.sliceIndexSlider);
                    this.drawCurrentSlice();
                };
                this.elements.btnSlicePlayPause.onclick = () => this.toggleSliceAnimation();

                this.elements.multiSelectCheckbox.onchange = (e) => this.toggleMultiSelectMode(e.target.checked);

                // Event listeners for slice grid hover/click
                this.elements.sliceCanvas.addEventListener('mousemove', this._boundHandleSliceHover);
                this.elements.sliceCanvas.addEventListener('mouseleave', this._boundHandleSliceLeave);
                this.elements.sliceCanvas.addEventListener('click', this._boundHandleSliceClick);
                this.elements.sliceGridContainer.addEventListener('mousemove', this._boundHandleGridHover);
                this.elements.sliceGridContainer.addEventListener('mouseleave', this._boundHandleGridLeave);
                this.elements.sliceGridContainer.addEventListener('click', this._boundHandleGridClick);
                this.elements.sliceGridContainer.addEventListener('dblclick', this._boundHandleGridDoubleClick);
            }
            
            toggleReplayAnimation() {
                if (this.replayAnimationTimer) {
                    clearInterval(this.replayAnimationTimer);
                    this.replayAnimationTimer = null;
                    this.elements.replayPlayIcon.classList.remove('hidden');
                    this.elements.replayPauseIcon.classList.add('hidden');
                } else {
                    const slider = this.elements.playbackSlider;
                    if (parseInt(slider.value, 10) >= parseInt(slider.max, 10)) {
                        slider.value = 0; // Restart if at the end
                    }
                    this.elements.replayPlayIcon.classList.add('hidden');
                    this.elements.replayPauseIcon.classList.remove('hidden');
                    this.replayAnimationTimer = setInterval(() => this.stepPlayback(), 50); // ~20 FPS replay
                }
            }
        
            stepPlayback() {
                const slider = this.elements.playbackSlider;
                let currentValue = parseInt(slider.value, 10);
                const maxValue = parseInt(slider.max, 10);
                
                const stepSize = Math.max(1, Math.floor(this.totalSimSteps / 200)); 
                currentValue += stepSize;
        
                if (currentValue >= maxValue) {
                    currentValue = 0; // Loop back to the beginning
                }
        
                slider.value = currentValue;
                this.handlePlaybackScrub();
            }

            toggleSliceAnimation() {
                if (this.sliceAnimationTimer) {
                    clearInterval(this.sliceAnimationTimer);
                    this.sliceAnimationTimer = null;
                    this.elements.slicePlayIcon.classList.remove('hidden');
                    this.elements.slicePauseIcon.classList.add('hidden');
                } else {
                    this.elements.slicePlayIcon.classList.add('hidden');
                    this.elements.slicePauseIcon.classList.remove('hidden');
                    this.sliceAnimationTimer = setInterval(() => this.stepSliceIndex(), 1000);
                }
            }

            stepSliceIndex() {
                const slider = this.elements.sliceIndexSlider;
                let currentValue = parseInt(slider.value, 10);
                const maxValue = parseInt(slider.max, 10);
                const minValue = parseInt(slider.min, 10);
                currentValue++;
                if (currentValue > maxValue) {
                    currentValue = minValue;
                }
                slider.value = currentValue;
                
                // Manually trigger the input event logic
                this.elements.sliceIndexLabel.textContent = slider.value;
                this.updateSliderTrackColor(slider);
                this.drawCurrentSlice();
            }
            
            async handleTooltipShow(event) {
                 const tooltip = this.elements.dynamicTooltip;
                 if (!tooltip) return;
                 const tooltipHost = event.target.closest('[data-tooltip-content]');
 
                 const sliceCanvasHost = event.target.closest('#sliceCanvas');
                 const sliceGridHost = event.target.closest('.slice-grid-cell');
                 
                 // Value tooltip for slice views (only if not in multi-select mode analysis)
                 if ((sliceCanvasHost || sliceGridHost) && this.finalStateSnapshot && !this.isMultiSelectMode) {
                     const N = this.simulator.N;
                     let gridX, gridY;
 
                     if(sliceCanvasHost){
                         const rect = sliceCanvasHost.getBoundingClientRect();
                         const mouseX = event.clientX - rect.left;
                         const mouseY = event.clientY - rect.top;
                         gridX = Math.floor((mouseX / sliceCanvasHost.clientWidth) * N);
                         gridY = Math.floor((mouseY / sliceCanvasHost.clientHeight) * N);
                     } else {
                         gridX = parseInt(sliceGridHost.dataset.x, 10);
                         gridY = parseInt(sliceGridHost.dataset.y, 10);
                     }
 
                     if (this.currentSliceData.data && gridX >= 0 && gridX < N && gridY >= 0 && gridY < N) {
                         const value = this.currentSliceData.data[gridX][gridY];
                         tooltip.innerHTML = value.toPrecision(4);
                         tooltip.style.left = `${event.pageX + 15}px`;
                         tooltip.style.top = `${event.pageY + 15}px`;
                         tooltip.classList.add('show');
                         return; // Prioritize value tooltip
                     }
                 }
 
                 // General purpose tooltip for descriptive text
                 if (this.tooltipsEnabled && tooltipHost) {
                     tooltip.innerHTML = tooltipHost.dataset.tooltipContent;
                     
                     // Await MathJax rendering to ensure we get the tooltip's final dimensions
                     if (window.MathJax?.typesetPromise) {
                        await window.MathJax.typesetPromise([tooltip]);
                     }
                     
                     const hostRect = tooltipHost.getBoundingClientRect();
                     const tooltipWidth = tooltip.offsetWidth;
                     const tooltipHeight = tooltip.offsetHeight;
 
                     // Position horizontally centered above the element
                     let left = window.scrollX + hostRect.left + (hostRect.width / 2) - (tooltipWidth / 2);
                     let top = window.scrollY + hostRect.top - tooltipHeight - 5; // 5px gap from the top of the element
 
                     // Boundary checks to prevent tooltip from going off-screen
                     if (left < window.scrollX + 5) {
                         left = window.scrollX + 5;
                     }
                     if ((left + tooltipWidth) > (window.scrollX + window.innerWidth - 5)) {
                         left = window.scrollX + window.innerWidth - tooltipWidth - 5;
                     }
                     if (top < window.scrollY + 5) {
                        // If it would go off the top of the viewport, show it below the element instead
                        top = window.scrollY + hostRect.bottom + 5;
                     }
 
                     tooltip.style.left = `${left}px`;
                     tooltip.style.top = `${top}px`;
                     tooltip.classList.add('show');
                 }
            }

            handleTooltipHide() {
                const tooltip = this.elements.dynamicTooltip;
                if(tooltip) {
                     tooltip.classList.remove('show');
                }
            }
            
            updateSliceHighlight(gridX, gridY) {
                if (this.lastHighlightedCell) {
                    this.lastHighlightedCell.classList.remove('slice-grid-cell-highlight');
                }
            
                if (gridX === null || !this.finalStateSnapshot) {
                    this.lastHighlightedCell = null;
                    return;
                }
            
                const cellId = `slice-cell-${gridX}-${gridY}`;
                const cell = document.getElementById(cellId);
            
                if (cell) {
                    cell.classList.add('slice-grid-cell-highlight');
                    this.lastHighlightedCell = cell;
                }
            }

            handleSliceHover(event) {
                if (!this.currentSliceData.data) return;
                const canvas = this.elements.sliceCanvas;
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                const N = this.simulator.N;
                const gridX = Math.floor((mouseX / canvas.clientWidth) * N);
                const gridY = Math.floor((mouseY / canvas.clientHeight) * N);

                this.updateSliceHighlight(gridX, gridY);
                this.updateLiveValueDisplay(gridX, gridY);
            }

            handleSliceLeave() { 
                this.updateSliceHighlight(null);
                this.updateLiveValueDisplay(null, null);
            }

            handleGridHover(event) {
                const cell = event.target.closest('.slice-grid-cell');
                if (!cell || !this.currentSliceData.data) {
                    this.updateSliceHighlight(null);
                    this.updateLiveValueDisplay(null, null);
                    return;
                }
                const gridX = parseInt(cell.dataset.x, 10);
                const gridY = parseInt(cell.dataset.y, 10);
                this.updateSliceHighlight(gridX, gridY);
                this.updateLiveValueDisplay(gridX, gridY);
            }

            handleGridLeave() {
                this.updateSliceHighlight(null); 
                this.updateLiveValueDisplay(null, null);
            }
            
            handleSliceClick(event) {
                if (!this.finalStateSnapshot || this.isMultiSelectMode) return;
                const canvas = this.elements.sliceCanvas;
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                const N = this.simulator.N;
                const gridX = Math.floor((mouseX / canvas.clientWidth) * N);
                const gridY = Math.floor((mouseY / canvas.clientHeight) * N);
                this.selectCell(gridX, gridY);
            }

            handleGridClick(event) {
                const cell = event.target.closest('.slice-grid-cell');
                if (!cell || !this.finalStateSnapshot) return;
                const gridX = parseInt(cell.dataset.x, 10);
                const gridY = parseInt(cell.dataset.y, 10);

                if (this.isMultiSelectMode) {
                    this.toggleMultiPixelSelection(gridX, gridY);
                } else {
                    this.selectCell(gridX, gridY);
                }
            }

            handleGridDoubleClick(event) {
                if (!this.isMultiSelectMode || this.selectedPixels.length === 0) return;
                
                const values = this.selectedPixels.map(p => this.currentSliceData.data[p.x][p.y]);
                const count = values.length;
                const sum = values.reduce((a, b) => a + b, 0);
                const mean = sum / count;
                const min = Math.min(...values);
                const max = Math.max(...values);
                const stdDev = Math.sqrt(values.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b, 0) / count);

                const tooltip = this.elements.dynamicTooltip;
                tooltip.innerHTML = `
                    <div class="font-bold text-center mb-2 border-b pb-1">Multi-Pixel Analysis</div>
                    <div class="tooltip-grid">
                        <span class="tooltip-grid-label">Count:</span> <span>${count}</span>
                        <span class="tooltip-grid-label">Mean:</span> <span>${mean.toExponential(3)}</span>
                        <span class="tooltip-grid-label">Std Dev:</span> <span>${stdDev.toExponential(3)}</span>
                        <span class="tooltip-grid-label">Min:</span> <span>${min.toExponential(3)}</span>
                        <span class="tooltip-grid-label">Max:</span> <span>${max.toExponential(3)}</span>
                    </div>
                `;
                tooltip.style.left = `${event.pageX + 15}px`;
                tooltip.style.top = `${event.pageY + 15}px`;
                tooltip.classList.add('show');
            }

            toggleMultiSelectMode(isActive) {
                this.isMultiSelectMode = isActive;
                this.elements.multiSelectActiveMessage.style.display = isActive ? 'block' : 'none';
                this.selectedPixels = []; // Reset selection
                
                // Clear all visual selections
                document.querySelectorAll('.slice-grid-cell-multiselected').forEach(el => el.classList.remove('slice-grid-cell-multiselected'));
                if (this.selectedCellElement) {
                    this.selectedCellElement.classList.remove('slice-grid-cell-selected');
                    this.selectedCellElement = null;
                }
            }

            updateLiveValueDisplay(gridX, gridY) {
                const { sliceValueSymbol, sliceLiveValue } = this.elements;
                const value = this.currentSliceData?.data?.[gridX]?.[gridY];
            
                if (typeof value !== 'number' || !isFinite(value)) {
                    sliceLiveValue.textContent = "N/A";
                    return;
                }
                
                const symbols = { vorticity: '|\\omega|', velocity: '|\\mathbf{u}|', pressure: 'p' };
                const variable = this.elements.sliceVariableSelect.value;
                sliceValueSymbol.textContent = `$${symbols[variable] || ''}$`;
                sliceLiveValue.textContent = value.toExponential(3);
            
                if (window.MathJax?.typesetPromise) {
                    window.MathJax.typesetPromise([sliceValueSymbol]);
                }
            }

            selectCell(gridX, gridY) {
                if (gridX === undefined || gridY === undefined || gridX === null || gridY === null) return;

                if (this.selectedCellElement) {
                    this.selectedCellElement.classList.remove('slice-grid-cell-selected');
                }
                const cellId = `slice-cell-${gridX}-${gridY}`;
                this.selectedCellElement = document.getElementById(cellId);
                if (this.selectedCellElement) {
                    this.selectedCellElement.classList.add('slice-grid-cell-selected');
                }
                
                const axis = this.elements.sliceAxisSelect.value;
                const sliceIndex = parseInt(this.elements.sliceIndexSlider.value);
                
                this.selectedPoint.gridX = gridX;
                this.selectedPoint.gridY = gridY;

                if (axis === 'z') { this.selectedPoint.i = gridX + 1; this.selectedPoint.j = gridY + 1; this.selectedPoint.k = sliceIndex; }
                else if (axis === 'y') { this.selectedPoint.i = gridX + 1; this.selectedPoint.j = sliceIndex; this.selectedPoint.k = gridY + 1; }
                else if (axis === 'x') { this.selectedPoint.i = sliceIndex; this.selectedPoint.j = gridX + 1; this.selectedPoint.k = gridY + 1; }

                this.showMathDetails();
            }

            showMathDetails() {
                if (!this.selectedPoint.i || !this.finalStateSnapshot) return;

                const { i, j, k } = this.selectedPoint;
                this.elements.mathDetailCoords.textContent = `${i-1}, ${j-1}, ${k-1}`;
                
                const data = this.finalStateSnapshot;
                const h2 = 2 * this.simulator.dx;

                const u = data.u[i][j][k], v = data.v[i][j][k], w = data.w[i][j][k];
                const p = data.p[i][j][k];

                const dWdY = (data.w[i][j+1][k] - data.w[i][j-1][k]) / h2;
                const dVdZ = (data.v[i][j][k+1] - data.v[i][j][k-1]) / h2;
                const omegaX = dWdY - dVdZ;

                const dUdZ = (data.u[i][j][k+1] - data.u[i][j][k-1]) / h2;
                const dWdX = (data.w[i+1][j][k] - data.w[i-1][j][k]) / h2;
                const omegaY = dUdZ - dWdX;

                const dVdX = (data.v[i+1][j][k] - data.v[i-1][j][k]) / h2;
                const dUdY = (data.u[i][j+1][k] - data.u[i][j-1][k]) / h2;
                const omegaZ = dVdX - dUdY;
                
                const velMag = Math.sqrt(u*u + v*v + w*w);
                const vortMag = Math.sqrt(omegaX*omegaX + omegaY*omegaY + omegaZ*omegaZ);
                
                const f = (num) => num.toExponential(3);

                const content = `
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
                        <div class="bg-gray-100 p-3 rounded-md border">
                            <h4 class="font-bold text-gray-700 mb-2">Primary Vectors</h4>
                            <p>Velocity $\\mathbf{u} = (u, v, w)$</p>
                            <p class="font-mono text-sm pl-4">(${f(u)}, ${f(v)}, ${f(w)})</p>
                            <p class="mt-2">Vorticity $\\omega = \\nabla \\times \\mathbf{u}$</p>
                            <p class="font-mono text-sm pl-4">(${f(omegaX)}, ${f(omegaY)}, ${f(omegaZ)})</p>
                        </div>
                        <div class="bg-gray-100 p-3 rounded-md border">
                            <h4 class="font-bold text-gray-700 mb-2">Scalar Quantities</h4>
                            <p>Pressure $p$: <span class="font-mono">${f(p)}</span></p>
                            <p>Velocity Magnitude $|\\mathbf{u}|$: <span class="font-mono">${f(velMag)}</span></p>
                            <p>Vorticity Magnitude $|\\omega|$: <span class="font-mono">${f(vortMag)}</span></p>
                        </div>
                        <div class="col-span-full bg-gray-100 p-3 rounded-md border">
                            <h4 class="font-bold text-gray-700 mb-2">Local Velocity Gradients (Strain-Rate Tensor Components)</h4>
                            <div class="grid grid-cols-3 gap-2 font-mono text-xs">
                                <div>$\\frac{\\partial u}{\\partial x} = ${f((data.u[i+1][j][k] - data.u[i-1][j][k]) / h2)}$</div>
                                <div>$\\frac{\\partial u}{\\partial y} = ${f(dUdY)}$</div>
                                <div>$\\frac{\\partial u}{\\partial z} = ${f(dUdZ)}$</div>
                                <div>$\\frac{\\partial v}{\\partial x} = ${f(dVdX)}$</div>
                                <div>$\\frac{\\partial v}{\\partial y} = ${f((data.v[i][j+1][k] - data.v[i][j-1][k]) / h2)}$</div>
                                <div>$\\frac{\\partial v}{\\partial z} = ${f(dVdZ)}$</div>
                                <div>$\\frac{\\partial w}{\\partial x} = ${f(dWdX)}$</div>
                                <div>$\\frac{\\partial w}{\\partial y} = ${f(dWdY)}$</div>
                                <div>$\\frac{\\partial w}{\\partial z} = ${f((data.w[i][j][k+1] - data.w[i][j][k-1]) / h2)}$</div>
                            </div>
                        </div>
                    </div>
                `;
                this.elements.mathDetailContent.innerHTML = content;
                this.showModal('mathDetailModal');
            }

            applyPreset(config) {
                if (this.isSimulationRunning) this.handleRunStop();
                this.elements.inputGridSize.value = config.gridSize;
                this.elements.paramGridSize.value = config.gridSize;
                this.elements.inputViscosity.value = config.viscosity.toFixed(3);
                this.elements.paramViscosity.value = config.viscosity;
                this.elements.inputDt.value = config.dt.toFixed(3);
                this.elements.paramDt.value = config.dt;
                this.elements.inputSimTime.value = config.simTime;
                this.elements.paramSimTime.value = config.simTime;
                this.elements.paramInitCondition.value = config.initCondition;
                this.elements.paramVisualization.value = config.visualization;
                this.updateAllSliderTrackColors();
                this.refreshApplication();
                this.handleRunStop();
            }
            
            setupAnimationLoop() {
                const animate = () => {
                    this.animationFrameId = requestAnimationFrame(animate);

                    // Main viewer
                    if (this.controls && this.renderer) {
                        this.controls.update();
                        this.renderer.render(this.scene, this.camera);
                    }
            
                    const is3DTabActive = this.elements.slicingContent3D.classList.contains('active');
            
                    // 3D Volumetric viewer
                    if (this.controls3DSlice && this.renderer3DSlice && is3DTabActive) {
                        this.controls3DSlice.update();
                        this.renderer3DSlice.render(this.scene3DSlice, this.camera3DSlice);
                    }
                    
                    // 3D Grid viewer
                    if (this.controls3DGrid && this.renderer3DGrid && is3DTabActive) {
                        this.controls3DGrid.update();
                        this.renderer3DGrid.render(this.scene3DGrid, this.camera3DGrid);
                    }
                };
                animate();
            }

            initThreeJs() {
                const container = this.elements.threeJsContainer;
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf0f0f0);
                this.camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                this.camera.position.set(0.5, 0.5, 1.5);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                container.appendChild(this.renderer.domElement);
                
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.target.set(0.5, 0.5, 0.5);
                
                this.scene.add(new THREE.AmbientLight(0xcccccc));
                const box = new THREE.Box3(new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 1, 1));
                const helper = new THREE.Box3Helper(box, 0x333333);
                this.scene.add(helper);

                this.scene.add(this.velocityArrows, this.densitySpheres, this.vorticitySpheres);
            }

            init3DSliceViewers() {
                 // Volumetric Viewer
                const containerVol = this.elements.threeJsSliceContainer;
                this.scene3DSlice = new THREE.Scene();
                this.scene3DSlice.background = new THREE.Color(0xe5e7eb);
                this.camera3DSlice = new THREE.PerspectiveCamera(75, containerVol.clientWidth / containerVol.clientHeight, 0.1, 1000);
                this.camera3DSlice.position.set(0.5, 0.5, 1.5);
                this.renderer3DSlice = new THREE.WebGLRenderer({ antialias: true });
                this.renderer3DSlice.setSize(containerVol.clientWidth, containerVol.clientHeight);
                containerVol.appendChild(this.renderer3DSlice.domElement);
                this.controls3DSlice = new THREE.OrbitControls(this.camera3DSlice, this.renderer3DSlice.domElement);
                this.controls3DSlice.enableDamping = true;
                this.controls3DSlice.target.set(0.5, 0.5, 0.5);
                this.scene3DSlice.add(new THREE.AmbientLight(0xcccccc));
                const lightVol = new THREE.DirectionalLight(0xffffff, 0.8);
                lightVol.position.set(1, 1, 1);
                this.scene3DSlice.add(lightVol);
                const boxHelperVol = new THREE.Box3Helper(new THREE.Box3(new THREE.Vector3(0,0,0), new THREE.Vector3(1,1,1)), 0x333333);
                this.scene3DSlice.add(boxHelperVol);
                this.scene3DSlice.add(this.volumeVoxels);

                // 3D Grid Viewer
                const containerGrid = this.elements.threeJsGridContainer;
                this.scene3DGrid = new THREE.Scene();
                this.scene3DGrid.background = new THREE.Color(0xe5e7eb);
                this.camera3DGrid = new THREE.PerspectiveCamera(60, containerGrid.clientWidth / containerGrid.clientHeight, 0.1, 1000);
                this.camera3DGrid.position.set(0.5, 0.8, 1.8);
                this.renderer3DGrid = new THREE.WebGLRenderer({ antialias: true });
                this.renderer3DGrid.setSize(containerGrid.clientWidth, containerGrid.clientHeight);
                containerGrid.appendChild(this.renderer3DGrid.domElement);
                this.controls3DGrid = new THREE.OrbitControls(this.camera3DGrid, this.renderer3DGrid.domElement);
                this.controls3DGrid.enableDamping = true;
                this.controls3DGrid.target.set(0.5, 0.2, 0.5);
                this.scene3DGrid.add(new THREE.AmbientLight(0xdddddd));
                const light = new THREE.DirectionalLight(0xffffff, 0.8);
                light.position.set(1, 1, 0.5);
                this.scene3DGrid.add(light);
                const gridHelper = new THREE.GridHelper(1, 10);
                gridHelper.position.set(0.5, 0, 0.5);
                this.scene3DGrid.add(gridHelper);
                this.scene3DGrid.add(this.gridBars);
            }
            
            onWindowResize() {
                // Main viewer
                if (this.renderer) {
                    const container = this.elements.threeJsContainer;
                    this.camera.aspect = container.clientWidth / container.clientHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(container.clientWidth, container.clientHeight);
                }
                
                // 3D Slice viewer
                if (this.renderer3DSlice) {
                    const container = this.elements.threeJsSliceContainer;
                    this.camera3DSlice.aspect = container.clientWidth / container.clientHeight;
                    this.camera3DSlice.updateProjectionMatrix();
                    this.renderer3DSlice.setSize(container.clientWidth, container.clientHeight);
                }

                // 3D Grid viewer
                if (this.renderer3DGrid) {
                    const container = this.elements.threeJsGridContainer;
                    this.camera3DGrid.aspect = container.clientWidth / container.clientHeight;
                    this.camera3DGrid.updateProjectionMatrix();
                    this.renderer3DGrid.setSize(container.clientWidth, container.clientHeight);
                }
                
                Object.values(this.charts).forEach(chart => chart.resize());
            }

            refreshApplication() {
                // This function performs a "deep reset" of the application, similar to a full reload.
                // It flushes all simulation data, resets all UI components, and re-initializes the simulation environment.
                this.isSimulationRunning = false; this.isSimulationPaused = false; this.isSimulationFinished = false; this.currentSimStep = 0;
                this.finalStateSnapshot = null; this.simulationSnapshots = []; this.simulationTimeSteps = [];
                this.elements.progressBar.style.width = '0%';
                if (this.sliceAnimationTimer) this.toggleSliceAnimation();
                if (this.replayAnimationTimer) this.toggleReplayAnimation();
                this.toggleMultiSelectMode(false);
                this.elements.multiSelectCheckbox.checked = false;
                
                // Hide the placeholder and show the analysis tab section from the start.
                this.elements.derivedMetricsWrapper.style.display = 'none';
                this.elements.analysisPlaceholderWrapper.style.display = 'none';
                this.elements.analysisPlaceholderWrapper.classList.remove('active');

                // Activate the default tab. The click handler will manage showing the correct content pane.
                this.elements.tabDistribution.click();
                
                const N = parseInt(this.elements.paramGridSize.value);
                this.elements.performanceWarning.style.display = N > 24 ? 'block' : 'none';
                
                this.simulator = new FluidSimulator3D(N, parseFloat(this.elements.paramViscosity.value), parseFloat(this.elements.paramDt.value));
                this.totalSimSteps = parseInt(this.elements.paramSimTime.value);

                this.elements.playbackSlider.value = 0;
                this.elements.playbackSlider.max = this.totalSimSteps;
                this.elements.playbackCurrentTime.textContent = 'Step: 0';
                this.elements.playbackTotalTime.textContent = `Total: ${this.totalSimSteps}`;
                
                const initType = this.elements.paramInitCondition.value;
                const center = Math.floor(N / 2) + 1;
                const radius = Math.floor(N / 4);

                // Intelligently set the initial slice index to where the action is.
                let initialSliceIndex = center;
                if (initType === 'jet') {
                    initialSliceIndex = 1;
                }
                
                this.elements.sliceIndexSlider.max = N;
                this.elements.sliceIndexSlider.value = initialSliceIndex;
                this.elements.sliceIndexLabel.textContent = this.elements.sliceIndexSlider.value;
                
                if (initType === 'vortex') {
                    for (let i = 1; i <= N; i++) for (let j = 1; j <= N; j++) {
                        const dx_c = i - center; const dy_c = j - center;
                        const r = Math.sqrt(dx_c*dx_c + dy_c*dy_c);
                        if (r < radius && r > 1) { this.simulator.u[i][j][center] = -dy_c * 0.5; this.simulator.v[i][j][center] = dx_c * 0.5; }
                    }
                    this.simulator.density[center][center][center] = 10;
                } else if (initType === 'jet') {
                    for (let i = center - 2; i <= center + 2; i++) for (let j = center - 2; j <= center + 2; j++) {
                        this.simulator.w[i][j][1] = 10.0; this.simulator.density[i][j][1] = 10.0;
                    }
                } else if (initType === 'random') {
                    for (let i=1; i<=N; i++) for (let j=1; j<=N; j++) for (let l=1; l<=N; l++) {
                        this.simulator.u[i][j][l] = (Math.random() - 0.5) * 0.1;
                        this.simulator.v[i][j][l] = (Math.random() - 0.5) * 0.1;
                        this.simulator.density[i][j][l] = Math.random() > 0.9 ? 1 : 0;
                    }
                }
                
                // Explicitly clear and reset 3D slice/grid viewers
                this.scene3DSlice.remove(this.volumeVoxels);
                this.volumeVoxels = new THREE.Group();
                this.scene3DSlice.add(this.volumeVoxels);

                this.scene3DGrid.remove(this.gridBars);
                this.gridBars = new THREE.Group();
                this.scene3DGrid.add(this.gridBars);
                
                // Clear any selection state
                this.selectedPoint = { i: null, j: null, k: null, gridX: null, gridY: null };
                if (this.selectedCellElement) {
                    this.selectedCellElement.classList.remove('slice-grid-cell-selected');
                    this.selectedCellElement = null;
                }

                this.resetMetrics();
                this.update3DVisualization();

                // Explicitly draw the initial state for the slice viewers. 
                // This will also update the 3D grid viewer and color bars.
                this.drawCurrentSlice(this.simulator);
                this.draw3DVolume(this.simulator);

                this.updateButtonStates();
                this.updateAllSliderTrackColors();
            }

            finalizeSimulation() {
                this.isSimulationRunning = false;
                this.isSimulationFinished = true;
                if (this.replayAnimationTimer) this.toggleReplayAnimation();

                const deepCopy = (arr) => arr.map(plane => plane.map(row => new Float32Array(row)));
                this.finalStateSnapshot = {
                    u: deepCopy(this.simulator.u), v: deepCopy(this.simulator.v), w: deepCopy(this.simulator.w),
                    density: deepCopy(this.simulator.density), p: deepCopy(this.simulator.p),
                };

                this.updateButtonStates();
                this.showAnalysis();
                this.elements.playbackSlider.max = this.totalSimSteps;
                this.elements.playbackSlider.value = this.currentSimStep;
                this.elements.playbackCurrentTime.textContent = `Step: ${this.currentSimStep}`;
                this.updateSliderTrackColor(this.elements.playbackSlider);
            }

            handleRunStop() {
                if (this.isSimulationRunning) {
                    this.finalizeSimulation();
                } else {
                    this.isSimulationRunning = true;
                    this.isSimulationPaused = false;
                    
                    this.elements.analysisPlaceholderWrapper.classList.remove('active');
                    this.elements.analysisPlaceholderWrapper.style.display = 'none';
                    this.switchTab(this.elements.tabDistribution);

                    this.runSimulationLoop();
                    this.updateButtonStates();
                }
            }

            handlePauseResume() { if (this.isSimulationRunning) { this.isSimulationPaused = !this.isSimulationPaused; this.updateButtonStates(); } }

            runSimulationLoop() {
                if (this.isSimulationPaused || !this.isSimulationRunning) {
                     if (this.isSimulationRunning) {
                        this.animationFrameId = requestAnimationFrame(() => this.runSimulationLoop());
                     }
                     return;
                }

                if (this.currentSimStep >= this.totalSimSteps) {
                    this.finalizeSimulation();
                    return;
                }
                this.simulator.fluid_step();
                this.currentSimStep++;

                const snapshot_interval = Math.max(1, Math.floor(this.totalSimSteps / 100));
                if (this.currentSimStep % snapshot_interval === 0 || this.currentSimStep === this.totalSimSteps - 1) {
                    const deepCopy = (arr) => arr.map(plane => plane.map(row => new Float32Array(row)));
                    this.simulationSnapshots.push({
                        u: deepCopy(this.simulator.u), v: deepCopy(this.simulator.v), w: deepCopy(this.simulator.w),
                        density: deepCopy(this.simulator.density), p: deepCopy(this.simulator.p),
                    });
                    this.simulationTimeSteps.push(this.currentSimStep);
                }

                if (this.currentSimStep % 5 === 0) { this.updateMetrics(); }
                this.elements.progressBar.style.width = `${(this.currentSimStep / this.totalSimSteps) * 100}%`;
                this.elements.percentageCounter.textContent = `${Math.round((this.currentSimStep / this.totalSimSteps) * 100)}%`;
                
                if (this.currentSimStep % 2 === 0) {
                    this.update3DVisualization();
                    const is2DSliceTabActive = this.elements.slicingContent.classList.contains('active');
                    const is3DSliceTabActive = this.elements.slicingContent3D.classList.contains('active');
                    
                    if (is2DSliceTabActive || is3DSliceTabActive) {
                        this.drawCurrentSlice(this.simulator);
                    }
                    if (is3DSliceTabActive) {
                        this.draw3DVolume(this.simulator);
                    }
                }
                
                this.animationFrameId = requestAnimationFrame(() => this.runSimulationLoop());
            }

            handlePlaybackScrub() {
                if (this.simulationSnapshots.length === 0) return;
                const currentStep = parseFloat(this.elements.playbackSlider.value);
                this.elements.playbackCurrentTime.textContent = `Step: ${Math.round(currentStep)}`;
                this.updateSliderTrackColor(this.elements.playbackSlider);
                const snapshotIndex = this.findSnapshotIndexForStep(currentStep);
                const selectedSnapshot = this.simulationSnapshots[snapshotIndex];
                this.update3DVisualization(selectedSnapshot);
                this.drawCurrentSlice(selectedSnapshot);
                this.draw3DVolume(selectedSnapshot);
            }

            findSnapshotIndexForStep(step) {
                if (this.simulationTimeSteps.length === 0) return 0;
                return this.simulationTimeSteps.reduce((prev, curr, i) =>
                    (Math.abs(curr - step) < Math.abs(this.simulationTimeSteps[prev] - step) ? i : prev), 0);
            }

            update3DVisualization(sourceData = this.simulator) {
                const N = this.simulator.N, dx = this.simulator.dx, offset = 0.5 * dx;
                const sampleRate = Math.max(1, Math.floor(N / 12));
                const MAX_VORT_FOR_COLOR = 20.0;
                
                this.velocityArrows.visible = this.visualizationMode === 'velocity';
                this.densitySpheres.visible = this.visualizationMode === 'density';
                this.vorticitySpheres.visible = this.visualizationMode === 'vorticity';
                const scene = this.velocityArrows.visible ? this.velocityArrows : (this.densitySpheres.visible ? this.densitySpheres : this.vorticitySpheres);
                while(scene.children.length) scene.remove(scene.children[0]);
                
                let vorticity = (this.visualizationMode === 'vorticity' || this.visualizationMode === 'velocity') ? this.simulator.calculateVorticity(sourceData) : null;
                let vorticityMag = vorticity ? this.simulator.calculateVorticityMagnitude(vorticity) : null;

                for (let i=1; i<=N; i+=sampleRate) for (let j=1; j<=N; j+=sampleRate) for (let l=1; l<=N; l+=sampleRate) {
                    const x_pos = (i - 1) * dx + offset; const y_pos = (j - 1) * dx + offset; const z_pos = (l - 1) * dx + offset;
                    if (this.visualizationMode === 'velocity') {
                        const velocity = new THREE.Vector3(sourceData.u[i][j][l], sourceData.v[i][j][l], sourceData.w[i][j][l]);
                        const mag = velocity.length();
                        if (mag > 0.01) {
                            const hue = (1 - Math.min(vorticityMag[i][j][l] / MAX_VORT_FOR_COLOR, 1.0)) * 0.4 + 0.0; // Green to Red
                            const arrow = new THREE.ArrowHelper(velocity.normalize(), new THREE.Vector3(x_pos, y_pos, z_pos), Math.min(mag * 2, dx * 1.5), new THREE.Color().setHSL(hue, 0.9, 0.5));
                            scene.add(arrow);
                        }
                    } else if (this.visualizationMode === 'density' && sourceData.density[i][j][l] > 0.1) {
                        const sphere = new THREE.Mesh(new THREE.SphereGeometry(dx * 0.4, 8, 8), new THREE.MeshBasicMaterial({ color: 0xfca5a5, transparent: true, opacity: Math.min(sourceData.density[i][j][l] * 0.5, 0.8) }));
                        sphere.position.set(x_pos, y_pos, z_pos); scene.add(sphere);
                    } else if (this.visualizationMode === 'vorticity' && vorticityMag[i][j][l] > 1.0) {
                        const sphere = new THREE.Mesh(new THREE.SphereGeometry(dx * 0.4, 8, 8), new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL((1 - Math.min(vorticityMag[i][j][l] / 50, 1.0)) * 0.4, 1.0, 0.5), transparent: true, opacity: Math.min(vorticityMag[i][j][l] * 0.1, 0.8) }));
                        sphere.position.set(x_pos, y_pos, z_pos); scene.add(sphere);
                    }
                }
            }

            resetMetrics() {
                this.metricsHistory = { ke: [], enstrophy: [], helicity: [], maxVort: [], time: [] };
                this.maxMetrics = { ke: 0, enstrophy: 0, helicity: 0, maxVel: 0, maxVort: 0 };
                ['metricKE_current', 'metricKE_max', 'metricEnstrophy_current', 'metricEnstrophy_max', 'metricHelicity_current', 'metricHelicity_max', 'metricAvgDiv_current'].forEach(id => this.elements[id].textContent = '0.0000');
                ['metricMaxVel_current', 'metricMaxVel_max', 'metricMaxVort_current', 'metricMaxVort_max'].forEach(id => this.elements[id].textContent = '0.000');
                Object.values(this.charts).forEach(chart => chart?.destroy());
                this.initializeCharts();
            }

            updateMetrics() {
                const vorticity = this.simulator.calculateVorticity();
                const vorticityMag = this.simulator.calculateVorticityMagnitude(vorticity);
                const helicity = this.simulator.calculateHelicity(vorticity);
                const ke = this.simulator.calculateMetric((i,j,l) => 0.5 * (this.simulator.u[i][j][l]**2 + this.simulator.v[i][j][l]**2 + this.simulator.w[i][j][l]**2));
                const enstrophy = this.simulator.calculateMetric((i,j,l) => 0.5 * vorticityMag[i][j][l]**2);
                let maxVel = 0, maxVort = 0;
                for (let i = 1; i <= this.simulator.N; i++) for (let j = 1; j <= this.simulator.N; j++) for (let l = 1; l <= this.simulator.N; l++) {
                    maxVel = Math.max(maxVel, Math.sqrt(this.simulator.u[i][j][l]**2 + this.simulator.v[i][j][l]**2 + this.simulator.w[i][j][l]**2));
                    maxVort = Math.max(maxVort, vorticityMag[i][j][l]);
                }
                const avgDiv = this.simulator.calculateMetric((i,j,l) => Math.abs(-0.5/this.simulator.dx * (this.simulator.u[i+1][j][l] - this.simulator.u[i-1][j][l] + this.simulator.v[i][j+1][l] - this.simulator.v[i][j-1][l] + this.simulator.w[i][j][l+1] - this.simulator.w[i][j][l-1])));

                this.metricsHistory.ke.push(ke); this.metricsHistory.enstrophy.push(enstrophy); this.metricsHistory.helicity.push(helicity); this.metricsHistory.maxVort.push(maxVort); this.metricsHistory.time.push(this.currentSimStep);
                this.maxMetrics.ke = Math.max(this.maxMetrics.ke, ke); this.maxMetrics.enstrophy = Math.max(this.maxMetrics.enstrophy, enstrophy); this.maxMetrics.helicity = Math.max(this.maxMetrics.helicity, Math.abs(helicity));
                this.maxMetrics.maxVel = Math.max(this.maxMetrics.maxVel, maxVel); this.maxMetrics.maxVort = Math.max(this.maxMetrics.maxVort, maxVort);
                
                this.elements.metricKE_current.textContent = ke.toExponential(2); this.elements.metricKE_max.textContent = this.maxMetrics.ke.toExponential(2);
                this.elements.metricEnstrophy_current.textContent = enstrophy.toExponential(2); this.elements.metricEnstrophy_max.textContent = this.maxMetrics.enstrophy.toExponential(2);
                this.elements.metricHelicity_current.textContent = helicity.toExponential(2); this.elements.metricHelicity_max.textContent = this.maxMetrics.helicity.toExponential(2);
                this.elements.metricMaxVel_current.textContent = maxVel.toFixed(3); this.elements.metricMaxVel_max.textContent = this.maxMetrics.maxVel.toFixed(3);
                this.elements.metricMaxVort_current.textContent = maxVort.toFixed(3); this.elements.metricMaxVort_max.textContent = this.maxMetrics.maxVort.toFixed(3);
                this.elements.metricAvgDiv_current.textContent = avgDiv.toExponential(2);
                
                this.updateCharts();
            }

            initializeCharts() {
                const createChart = (canvasId, label, color) => {
                    if (!this.elements[canvasId]) return null;
                    const ctx = this.elements[canvasId].getContext('2d');
                    return new Chart(ctx, {
                        type: 'line', data: { labels: [], datasets: [{ label, data: [], borderColor: color, borderWidth: 2, pointRadius: 0, tension: 0.1 }] },
                        options: { 
                            responsive: true, maintainAspectRatio: false, 
                            layout: { padding: { left: 15 } },
                            scales: { x: { title: { display: true, text: 'Simulation Step' } }, y: { title: { display: true, text: label }, ticks: { callback: value => value.toExponential(1) } } }, 
                            plugins: { legend: { display: false }, title: {display: true, text: label} }
                        }
                    });
                };
                const createBarChart = (canvasId, label, color) => {
                    if (!this.elements[canvasId]) return null;
                    const ctx = this.elements[canvasId].getContext('2d');
                    return new Chart(ctx, {
                        type: 'bar', data: { labels: [], datasets: [{ label, data: [], backgroundColor: color }] },
                        options: { responsive: true, maintainAspectRatio: false, scales: { x: { title: { display: true, text: 'Magnitude Bins' } }, y: { title: { display: true, text: 'Frequency' }, beginAtZero: true } }, plugins: { legend: { display: false }, title: {display: true, text: label} } }
                    });
                }
                this.charts.ke = createChart('keChartCanvas', 'Kinetic Energy', '#4F46E5');
                this.charts.enstrophy = createChart('enstrophyChartCanvas', 'Enstrophy', '#EF4444');
                this.charts.helicity = createChart('helicityChartCanvas', 'Helicity', '#10B981');
                this.charts.maxVort = createChart('maxVortChartCanvas', 'Max Vorticity', '#8B5CF6');
                this.charts.velDist = createBarChart('velocityDistChartCanvas', 'Velocity Magnitude Distribution', 'rgba(79, 70, 229, 0.6)');
                this.charts.vortDist = createBarChart('vorticityDistChartCanvas', 'Vorticity Magnitude Distribution', 'rgba(239, 68, 68, 0.6)');
                this.charts.pressureDist = createBarChart('pressureDistChartCanvas', 'Pressure Distribution', 'rgba(16, 185, 129, 0.6)');
                this.charts.helicityCosineDist = createBarChart('helicityCosineDistChartCanvas', 'Helicity Cosine Distribution', 'rgba(139, 92, 246, 0.6)');
                this.charts.energySpectrum = new Chart(this.elements.energySpectrumChartCanvas.getContext('2d'), {
                    type: 'scatter',
                    data: { datasets: [] },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        plugins: { legend: { display: true }, title: { display: false } },
                        scales: {
                            x: { type: 'logarithmic', title: { display: true, text: 'Wavenumber k' } },
                            y: { type: 'logarithmic', title: { display: true, text: 'Energy E(k)' } }
                        }
                    }
                });
            }
            
            updateCharts() {
                if(this.charts.ke) {
                    this.charts.ke.data.labels = this.metricsHistory.time;
                    this.charts.ke.data.datasets[0].data = this.metricsHistory.ke;
                    this.charts.ke.update('none');
                }
                if(this.charts.enstrophy) {
                    this.charts.enstrophy.data.labels = this.metricsHistory.time;
                    this.charts.enstrophy.data.datasets[0].data = this.metricsHistory.enstrophy;
                    this.charts.enstrophy.update('none');
                }
                 if(this.charts.helicity) {
                    this.charts.helicity.data.labels = this.metricsHistory.time;
                    this.charts.helicity.data.datasets[0].data = this.metricsHistory.helicity;
                    this.charts.helicity.update('none');
                }
                if(this.charts.maxVort) {
                    this.charts.maxVort.data.labels = this.metricsHistory.time;
                    this.charts.maxVort.data.datasets[0].data = this.metricsHistory.maxVort;
                    this.charts.maxVort.update('none');
                }
            }
            
            switchTab(tabElement) {
                const targetContentId = tabElement.dataset.tab;

                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.classList.remove('active-tab');
                    btn.classList.add('inactive-tab');
                });
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });

                tabElement.classList.remove('inactive-tab');
                tabElement.classList.add('active-tab');
                document.getElementById(targetContentId).classList.add('active');

                // Show/hide shared slice controls
                if (targetContentId === 'slicingContent' || targetContentId === 'slicingContent3D') {
                    this.elements.sliceControlsContainer.style.display = 'grid';
                } else {
                    this.elements.sliceControlsContainer.style.display = 'none';
                }

                // Determine the correct data source for redrawing content on tab switch.
                const sourceData = this.isSimulationFinished ? this.finalStateSnapshot : this.simulator;

                // Force re-draw of content when switching to a slice tab, if data is available.
                // This ensures that viewers are populated with the initial state on first click after a refresh,
                // and with the final state after a simulation is complete.
                if (sourceData) {
                    if (targetContentId === 'slicingContent') {
                        this.drawCurrentSlice(sourceData);
                    } else if (targetContentId === 'slicingContent3D') {
                        this.onWindowResize();
                        this.draw3DVolume(sourceData);
                        this.drawCurrentSlice(sourceData); // Also redraws the 3D grid view.
                    }
                }
            }

            showAnalysis() {
                if (!this.finalStateSnapshot) return;
                
                this.elements.analysisPlaceholderWrapper.classList.remove('active');
                this.elements.analysisPlaceholderWrapper.style.display = 'none';
                this.switchTab(this.elements.tabDistribution);

                // Derived Metrics Calculation
                const finalKE = this.metricsHistory.ke.slice(-1)[0] || 0;
                const finalEnstrophy = this.metricsHistory.enstrophy.slice(-1)[0] || 0;
                const viscosity = this.simulator.viscosity;
                const N = this.simulator.N;
                const dx = 1.0 / N;

                if (viscosity > 0 && finalEnstrophy > 0 && finalKE > 0) {
                    const re = (Math.sqrt(2 * finalKE) * 1.0) / viscosity; // L=1
                    const reTaylor = (Math.sqrt(2) * finalKE) / (viscosity * Math.sqrt(finalEnstrophy));
                    const epsilon = 2 * viscosity * finalEnstrophy;
                    const eta = Math.pow((viscosity**3) / epsilon, 0.25);
                    const lInt = Math.pow(finalKE, 1.5) / epsilon;
                    const dxEtaRatio = dx / eta;

                    this.elements.metricRe.textContent = re.toFixed(2);
                    this.elements.metricReTaylor.textContent = reTaylor.toFixed(2);
                    this.elements.metricEpsilon.textContent = epsilon.toExponential(2);
                    this.elements.metricEta.textContent = eta.toExponential(3);
                    this.elements.metricLInt.textContent = lInt.toExponential(3);
                    this.elements.metricDxEtaRatio.textContent = dxEtaRatio.toFixed(2);

                    this.elements.derivedMetricsWrapper.style.display = 'block';
                } else {
                    this.elements.derivedMetricsWrapper.style.display = 'none';
                }
                
                // --- Distribution Plots Calculation ---
                const finalVorticity = this.simulator.calculateVorticity(this.finalStateSnapshot);
                const finalVorticityMag = this.simulator.calculateVorticityMagnitude(finalVorticity);

                const velDistData = this.simulator.getDistribution((i,j,l) => Math.sqrt(this.finalStateSnapshot.u[i][j][l]**2 + this.finalStateSnapshot.v[i][j][l]**2 + this.finalStateSnapshot.w[i][j][l]**2));
                const vortDistData = this.simulator.getDistribution((i,j,l) => finalVorticityMag[i][j][l]);
                const pressureDistData = this.simulator.getDistribution((i,j,l) => this.finalStateSnapshot.p[i][j][l]);
                const helicityCosineDistData = this.simulator.getDistribution((i, j, l) => {
                    const { u, v, w } = { u: this.finalStateSnapshot.u[i][j][l], v: this.finalStateSnapshot.v[i][j][l], w: this.finalStateSnapshot.w[i][j][l] };
                    const { ox, oy, oz } = { ox: finalVorticity.omegaX[i][j][l], oy: finalVorticity.omegaY[i][j][l], oz: finalVorticity.omegaZ[i][j][l] };
                    const dotProduct = u * ox + v * oy + w * oz;
                    const uMag = Math.sqrt(u*u + v*v + w*w);
                    const oMag = finalVorticityMag[i][j][l];
                    if (uMag < 1e-9 || oMag < 1e-9) return 0;
                    return dotProduct / (uMag * oMag);
                }, 21, [-1, 1]);

                this.charts.velDist.data.labels = velDistData.labels; this.charts.velDist.data.datasets[0].data = velDistData.data; this.charts.velDist.update();
                this.charts.vortDist.data.labels = vortDistData.labels; this.charts.vortDist.data.datasets[0].data = vortDistData.data; this.charts.vortDist.update();
                this.charts.pressureDist.data.labels = pressureDistData.labels; this.charts.pressureDist.data.datasets[0].data = pressureDistData.data; this.charts.pressureDist.update();
                this.charts.helicityCosineDist.data.labels = helicityCosineDistData.labels; this.charts.helicityCosineDist.data.datasets[0].data = helicityCosineDistData.data; this.charts.helicityCosineDist.update();

                // --- Energy Spectrum Calculation ---
                this.calculateAndDisplayEnergySpectrum();

                // --- Slice Viewer Initialization ---
                this.drawCurrentSlice();
                this.draw3DVolume();
            }

            calculateAndDisplayEnergySpectrum() {
                const N = this.simulator.N;
                const u = this.finalStateSnapshot.u, v = this.finalStateSnapshot.v, w = this.finalStateSnapshot.w;
            
                // The FFT algorithm requires the size to be a power of two.
                const fft_N = 2 ** Math.ceil(Math.log2(N));

                const createPaddedComplexMatrix = (realMatrix, originalN, fftSize) => {
                    // Create a larger matrix padded with zeros
                    let complex = Array(fftSize).fill(0).map(() => Array(fftSize).fill(0).map(() => Array(fftSize).fill([0, 0])));
                    for (let i = 0; i < originalN; i++) {
                        for (let j = 0; j < originalN; j++) {
                            for (let l = 0; l < originalN; l++) {
                                complex[i][j][l] = [realMatrix[i + 1][j + 1][l + 1], 0]; // +1 for boundary
                            }
                        }
                    }
                    return complex;
                }
            
                const u_fft = FFT.fft3d(createPaddedComplexMatrix(u, N, fft_N), fft_N);
                const v_fft = FFT.fft3d(createPaddedComplexMatrix(v, N, fft_N), fft_N);
                const w_fft = FFT.fft3d(createPaddedComplexMatrix(w, N, fft_N), fft_N);
            
                const max_k = Math.floor(Math.sqrt(3) * (fft_N / 2));
                let energy = new Array(max_k + 1).fill(0);
                let counts = new Array(max_k + 1).fill(0);
            
                for (let i = 0; i < fft_N; i++) for (let j = 0; j < fft_N; j++) for (let l = 0; l < fft_N; l++) {
                    const kx = (i < fft_N / 2) ? i : i - fft_N;
                    const ky = (j < fft_N / 2) ? j : j - fft_N;
                    const kz = (l < fft_N / 2) ? l : l - fft_N;
                    
                    const k_mag = Math.sqrt(kx**2 + ky**2 + kz**2);
                    const k_bin = Math.round(k_mag);
                    
                    if (k_bin > 0 && k_bin <= max_k) {
                        const e_k = 0.5 * (FFT.complex.abs(u_fft[i][j][l])**2 + FFT.complex.abs(v_fft[i][j][l])**2 + FFT.complex.abs(w_fft[i][j][l])**2);
                        energy[k_bin] += e_k;
                        counts[k_bin]++;
                    }
                }
                
                let spectrumData = [];
                for (let k = 1; k <= max_k; k++) {
                    if (counts[k] > 0) {
                        spectrumData.push({x: k, y: energy[k] / counts[k]});
                    }
                }

                // Reference line k^(-5/3)
                const ref_k0 = spectrumData[Math.floor(spectrumData.length / 4)]?.x || 2;
                const ref_E0 = spectrumData[Math.floor(spectrumData.length / 4)]?.y || 1e-4;
                const C = (ref_E0 > 0 && ref_k0 > 0) ? ref_E0 / (ref_k0 ** (-5/3)) : 1e-6;
                let referenceLine = [];
                for(let k=1; k <= max_k; k++) {
                    referenceLine.push({x: k, y: C * (k ** (-5/3)) });
                }
            
                this.charts.energySpectrum.data.datasets = [
                    { label: 'Energy Spectrum', data: spectrumData, backgroundColor: '#4F46E5', pointRadius: 3 },
                    { label: 'k^(-5/3) slope', data: referenceLine, backgroundColor: '#EF4444', borderColor: '#EF4444', borderWidth: 2, pointRadius: 0, type: 'line', fill: false }
                ];
                this.charts.energySpectrum.update();
            }

            spectral(t) {
                // Volcano/spectral colormap: Dark Blue -> Blue -> Cyan -> Green -> Yellow -> Red -> Dark Red
                const clamp = (val, min, max) => Math.max(min, Math.min(val, max));
                t = clamp(t, 0.0, 1.0);
                let r, g, b;

                if (t < 0.15) { // Dark Blue to Blue
                    const nt = t / 0.15;
                    r = 0;
                    g = 0;
                    b = 104 + nt * (255 - 104);
                } else if (t < 0.35) { // Blue to Cyan
                    const nt = (t - 0.15) / 0.20;
                    r = 0;
                    g = nt * 255;
                    b = 255;
                } else if (t < 0.55) { // Cyan to Green
                    const nt = (t - 0.35) / 0.20;
                    r = 0;
                    g = 255;
                    b = 255 - nt * 255;
                } else if (t < 0.75) { // Green to Yellow
                    const nt = (t - 0.55) / 0.20;
                    r = nt * 255;
                    g = 255;
                    b = 0;
                } else if (t < 0.90) { // Yellow to Red
                    const nt = (t - 0.75) / 0.15;
                    r = 255;
                    g = 255 - nt * 255;
                    b = 0;
                } else { // Red to Dark Red
                    const nt = (t - 0.90) / 0.10;
                    r = 255 - nt * (255 - 104);
                    g = 0;
                    b = 0;
                }
                return [Math.round(r), Math.round(g), Math.round(b)];
            }
            
            drawColorbar(canvas) {
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                const gradient = ctx.createLinearGradient(0, 0, ctx.canvas.width, 0);
                for (let i = 0; i <= 1; i += 0.01) {
                    const [r, g, b] = this.spectral(i);
                    gradient.addColorStop(i, `rgb(${r},${g},${b})`);
                }
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            }

            drawCurrentSlice(sourceData = this.finalStateSnapshot) {
                if (!sourceData) return;
                const N = this.simulator.N;
                const variable = this.elements.sliceVariableSelect.value;
                const axis = this.elements.sliceAxisSelect.value;
                const sliceIndex = parseInt(this.elements.sliceIndexSlider.value);
            
                let data2d = new Array(N).fill(0).map(() => new Float32Array(N));
                let sliceScalarDataSource;
            
                if (variable === 'vorticity') {
                    const vorticity = this.simulator.calculateVorticity(sourceData);
                    sliceScalarDataSource = this.simulator.calculateVorticityMagnitude(vorticity);
                } else if (variable === 'pressure') {
                    sliceScalarDataSource = sourceData.p;
                }
            
                let minVal = Infinity, maxVal = -Infinity;
            
                for (let i = 0; i < N; i++) {
                    for (let j = 0; j < N; j++) {
                        let val;
                        if (variable === 'velocity') {
                            let u, v, w;
                            if (axis === 'z') {
                                u = sourceData.u[i + 1][j + 1][sliceIndex];
                                v = sourceData.v[i + 1][j + 1][sliceIndex];
                                w = sourceData.w[i + 1][j + 1][sliceIndex];
                            } else if (axis === 'y') {
                                u = sourceData.u[i + 1][sliceIndex][j + 1];
                                v = sourceData.v[i + 1][sliceIndex][j + 1];
                                w = sourceData.w[i + 1][sliceIndex][j + 1];
                            } else { // 'x'
                                u = sourceData.u[sliceIndex][i + 1][j + 1];
                                v = sourceData.v[sliceIndex][i + 1][j + 1];
                                w = sourceData.w[sliceIndex][i + 1][j + 1];
                            }
                            val = Math.sqrt(u*u + v*v + w*w);
                        } else {
                            if (axis === 'z') val = sliceScalarDataSource[i + 1][j + 1][sliceIndex];
                            else if (axis === 'y') val = sliceScalarDataSource[i + 1][sliceIndex][j + 1];
                            else val = sliceScalarDataSource[sliceIndex][i + 1][j + 1];
                        }
                        data2d[i][j] = val;
                        if (val < minVal) minVal = val;
                        if (val > maxVal) maxVal = val;
                    }
                }
                
                this.currentSliceData = { data: data2d, min: minVal, max: maxVal, variable, axis, index: sliceIndex };
                this.draw3DGrid();
            
                // Render heatmap to main canvas
                const ctx = this.elements.sliceCanvas.getContext('2d');
                const imageData = ctx.createImageData(N, N);
                for (let y = 0; y < N; y++) {
                    for (let x = 0; x < N; x++) {
                        const normalized = (maxVal > minVal) ? (data2d[x][y] - minVal) / (maxVal - minVal) : 0;
                        const [r, g, b] = this.spectral(normalized);
                        const index = (y * N + x) * 4;
                        imageData.data[index] = r;
                        imageData.data[index + 1] = g;
                        imageData.data[index + 2] = b;
                        imageData.data[index + 3] = 255;
                    }
                }
                
                const offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = N;
                offscreenCanvas.height = N;
                offscreenCanvas.getContext('2d').putImageData(imageData, 0, 0);
                
                ctx.imageSmoothingEnabled = false;
                ctx.clearRect(0, 0, 400, 400);
                ctx.drawImage(offscreenCanvas, 0, 0, 400, 400);

                // Populate the data grid
                const sliceGridContainer = this.elements.sliceGridContainer;
                sliceGridContainer.innerHTML = '';
                sliceGridContainer.style.setProperty('--slice-grid-n', N);

                for (let y = 0; y < N; y++) {
                    for (let x = 0; x < N; x++) {
                        const val = data2d[x][y];
                        const normalized = (maxVal > minVal) ? (val - minVal) / (maxVal - minVal) : 0;
                        const [r, g, b] = this.spectral(normalized);
                        
                        const cell = document.createElement('div');
                        cell.className = 'slice-grid-cell';
                        cell.id = `slice-cell-${x}-${y}`;
                        cell.dataset.x = x;
                        cell.dataset.y = y;
                        cell.style.backgroundColor = `rgba(${r},${g},${b}, 0.5)`;
                        sliceGridContainer.appendChild(cell);
                    }
                }

                // Re-apply selections after redraw
                if (this.isMultiSelectMode) {
                    this.selectedPixels.forEach(p => {
                       document.getElementById(`slice-cell-${p.x}-${p.y}`)?.classList.add('slice-grid-cell-multiselected');
                    });
                } else if (this.selectedCellElement && this.selectedPoint.gridX !== null) {
                    const cellId = `slice-cell-${this.selectedPoint.gridX}-${this.selectedPoint.gridY}`;
                    const newCellElement = document.getElementById(cellId);
                    if (newCellElement) {
                        newCellElement.classList.add('slice-grid-cell-selected');
                        this.selectedCellElement = newCellElement; // Update reference to the new DOM element
                    } else {
                        // The cell is gone, so clear selection state
                        this.selectedCellElement = null;
                        this.selectedPoint = { i: null, j: null, k: null, gridX: null, gridY: null };
                    }
                }
            
                // Render horizontal colorbar (for 2D view)
                this.drawColorbar(this.elements.sliceColorbarCanvas);
                this.elements.sliceColorbarMin.textContent = minVal.toExponential(2);
                this.elements.sliceColorbarMax.textContent = maxVal.toExponential(2);

                // Render horizontal colorbar (for 3D grid view)
                this.drawColorbar(this.elements.gridColorbarCanvas);
                this.elements.gridColorbarMin.textContent = minVal.toExponential(2);
                this.elements.gridColorbarMax.textContent = maxVal.toExponential(2);
            }

            draw3DVolume(sourceData = this.finalStateSnapshot) {
                if (!sourceData || !this.scene3DSlice) return;

                this.scene3DSlice.remove(this.volumeVoxels);
                this.volumeVoxels = new THREE.Group();
                this.scene3DSlice.add(this.volumeVoxels);
                
                const N = this.simulator.N;
                const dx = this.simulator.dx;
                const offset = 0.5 * dx;
                const variable = this.elements.sliceVariableSelect.value;
                let data3D;

                // 1. Get the 3D data and find min/max
                let minVal = Infinity, maxVal = -Infinity;

                if (variable === 'velocity') {
                    data3D = this.simulator.create3DArray();
                    for(let i=1; i<=N; i++) for(let j=1; j<=N; j++) for(let l=1; l<=N; l++) {
                        const val = Math.sqrt(sourceData.u[i][j][l]**2 + sourceData.v[i][j][l]**2 + sourceData.w[i][j][l]**2);
                        data3D[i][j][l] = val;
                        if(val < minVal) minVal = val; if(val > maxVal) maxVal = val;
                    }
                } else {
                     if (variable === 'vorticity') {
                        const vorticity = this.simulator.calculateVorticity(sourceData);
                        data3D = this.simulator.calculateVorticityMagnitude(vorticity);
                    } else if (variable === 'pressure') {
                        data3D = sourceData.p;
                    }
                     for(let i=1; i<=N; i++) for(let j=1; j<=N; j++) for(let l=1; l<=N; l++) {
                        const val = data3D[i][j][l];
                        if(val < minVal) minVal = val; if(val > maxVal) maxVal = val;
                    }
                }
                
                // Draw the colorbar for the volume
                this.drawColorbar(this.elements.volumeColorbarCanvas);
                this.elements.volumeColorbarMin.textContent = minVal.toExponential(2);
                this.elements.volumeColorbarMax.textContent = maxVal.toExponential(2);

                // 2. Create InstancedMesh
                const geometry = new THREE.BoxGeometry(dx * 0.8, dx * 0.8, dx * 0.8);
                const material = new THREE.MeshLambertMaterial({ transparent: true, opacity: 0.5 });
                
                const mesh = new THREE.InstancedMesh(geometry, material, N * N * N);
                
                const dummy = new THREE.Object3D();
                const color = new THREE.Color();
                let instanceId = 0;

                const range = (maxVal > minVal) ? (maxVal - minVal) : 0;
                // Only render voxels in the top 80% of the value range to reduce visual clutter,
                // unless the range of values is very small, in which case we show everything to avoid a blank screen.
                const threshold = (range > 1e-9) ? minVal + range * 0.2 : -Infinity;

                for (let i = 1; i <= N; i++) for (let j = 1; j <= N; j++) for (let l = 1; l <= N; l++) {
                    const val = data3D[i][j][l];
                    if (val > threshold) {
                        const normalized = (range > 0) ? (val - minVal) / range : 0;
                        const [r, g, b] = this.spectral(normalized);
                        color.setRGB(r / 255, g / 255, b / 255);
                        
                        dummy.position.set((i - 1) * dx + offset, (j - 1) * dx + offset, (l - 1) * dx + offset);
                        dummy.updateMatrix();

                        mesh.setMatrixAt(instanceId, dummy.matrix);
                        mesh.setColorAt(instanceId, color);
                        
                        instanceId++;
                    }
                }
                
                mesh.count = instanceId;
                mesh.instanceMatrix.needsUpdate = true;
                if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;
                
                this.volumeVoxels.add(mesh);
            }

            draw3DGrid() {
                 if (!this.currentSliceData.data || !this.scene3DGrid) return;

                this.scene3DGrid.remove(this.gridBars);
                this.gridBars = new THREE.Group();
                this.scene3DGrid.add(this.gridBars);

                const N = this.simulator.N;
                const dx = 1.0 / N;
                const offset = 0.5 * dx;
                const { data, min, max } = this.currentSliceData;

                const geometry = new THREE.BoxGeometry(dx * 0.8, 1, dx * 0.8); // Height is 1, will be scaled
                const material = new THREE.MeshLambertMaterial();
                const mesh = new THREE.InstancedMesh(geometry, material, N * N);

                const dummy = new THREE.Object3D();
                const color = new THREE.Color();
                const range = (max > min) ? (max - min) : 1;
                let instanceId = 0;
                
                for (let i = 0; i < N; i++) {
                    for (let j = 0; j < N; j++) {
                        const val = data[i][j];
                        const normalized = (val - min) / range;
                        const height = Math.max(0.01, normalized * 0.7); // Max height of 0.7

                        const [r, g, b] = this.spectral(normalized);
                        color.setRGB(r / 255, g / 255, b / 255);

                        dummy.position.set((i) * dx + offset, height / 2, (j) * dx + offset);
                        dummy.scale.set(1, height, 1);
                        dummy.updateMatrix();

                        mesh.setMatrixAt(instanceId, dummy.matrix);
                        mesh.setColorAt(instanceId, color);
                        instanceId++;
                    }
                }
                mesh.instanceMatrix.needsUpdate = true;
                if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;

                this.gridBars.add(mesh);
            }


            validateAndSetApiKey() {
                this.geminiApiKey = this.elements.geminiApiKeyInput.value.trim();
                this.updateButtonStates();
            }

            async interpretSimulationState(mode) {
                if (!this.geminiApiKey) {
                    this.showAiInterpretationModal(`<p class="text-red-600">Gemini API key is not provided. Please enter your API key.</p>`);
                    return;
                }
                if (!this.simulator || this.currentSimStep === 0) {
                    this.showAiInterpretationModal(`<p>Please run a simulation to generate data for interpretation.</p>`);
                    return;
                }
                
                this.showAiInterpretationModal();
                
                const lastKE = this.metricsHistory.ke.length > 0 ? this.metricsHistory.ke.slice(-1)[0] : 0;
                const lastEnstrophy = this.metricsHistory.enstrophy.length > 0 ? this.metricsHistory.enstrophy.slice(-1)[0] : 0;
                const lastHelicity = this.metricsHistory.helicity.length > 0 ? this.metricsHistory.helicity.slice(-1)[0] : 0;

                let prompt;
                if (mode === 'kids') {
                    prompt = `You are a friendly scientist named Einstein. Explain what's happening in my 3D "super soup" simulation to a 10-year-old. My soup has a "stickiness" of ${this.simulator.viscosity}. I started it by '${this.elements.paramInitCondition.value}'. The soup's total "splash energy" is ${lastKE.toExponential(2)} and its "swirliness" is ${lastEnstrophy.toExponential(2)}. The fastest drop is moving at ${this.maxMetrics.maxVel.toFixed(2)} and the fastest swirl is ${this.maxMetrics.maxVort.toFixed(2)}. Tell me a fun story about what my soup is doing!`;
                } else if (mode === 'qa') {
                    prompt = `Generate 5 insightful questions and detailed answers about the provided 3D fluid simulation data. Focus on the relationship between parameters (like viscosity) and outcomes (like turbulence, energy decay, and helicity). The simulation data is: Grid=${this.simulator.N}^3, Viscosity=${this.simulator.viscosity}, dt=${this.simulator.dt}, Final KE=${lastKE.toExponential(2)}, Final Enstrophy=${lastEnstrophy.toExponential(2)}. Format as a JSON array of objects, where each object has a 'question' and 'answer' key.`;
                } else { // 'expert' mode
                    prompt = `You are an expert in fluid dynamics interpreting a 3D Navier-Stokes simulation. Simulation parameters: Grid=${this.simulator.N}^3, Viscosity=${this.simulator.viscosity}, dt=${this.simulator.dt}, Current step ${this.currentSimStep}/${this.totalSimSteps}. Initial condition: ${this.elements.paramInitCondition.value}. Final Metrics: KE=${lastKE.toExponential(2)}, Enstrophy=${lastEnstrophy.toExponential(2)}, Helicity=${lastHelicity.toExponential(2)}, MaxVel=${this.maxMetrics.maxVel.toFixed(2)}, MaxVorticity=${this.maxMetrics.maxVort.toFixed(2)}. Provide a conceptual analysis of the flow's behavior, discussing turbulence, energy cascade, helicity, and vortex dynamics. Use Markdown and LaTeX.`;
                }

                try {
                    const genAI = new GoogleGenerativeAI(this.geminiApiKey);
                    const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

                    let result;
                    let text;
                    const isJson = (mode === 'qa');

                    if (isJson) {
                         const generationConfig = { responseMimeType: "application/json" };
                         result = await model.generateContent({
                            contents: [{ role: "user", parts: [{ text: prompt }] }],
                            generationConfig,
                         });
                         const response = await result.response;
                         text = response.text();
                    } else {
                        result = await model.generateContent(prompt);
                        const response = await result.response;
                        text = response.text();
                    }

                    let htmlContent = '';
                    if (isJson) {
                        if (text.startsWith("```json")) {
                           text = text.substring(7, text.length - 3).trim();
                        } else if (text.startsWith("```")) {
                           text = text.substring(3, text.length - 3).trim();
                        }
                        const qaPairs = JSON.parse(text);
                        qaPairs.forEach((item, index) => {
                           htmlContent += `<div class="mb-4 p-3 border border-gray-200 rounded-md bg-gray-50"><h4 class="font-bold text-lg text-gray-800 mb-1">Q${index+1}: ${item.question}</h4><p class="text-gray-700">${item.answer.replace(/\n/g, '<br>')}</p></div>`;
                        });
                    } else {
                        htmlContent = text.replace(/\n/g, '<br>');
                    }
                    this.showAiInterpretationModal(htmlContent);
                    if (window.MathJax?.typesetPromise) window.MathJax.typesetPromise([this.elements.aiInterpretationContent]);
                } catch (e) {
                    this.showAiInterpretationModal(`<p class="text-red-600">Failed to get AI interpretation: ${e.message}. Please check your API key and network connection.</p>`);
                }
            }
            
            showAiInterpretationModal(content = '') {
                this.showModal('aiInterpretationModal');
                if (content) {
                    this.elements.aiInterpretationContent.innerHTML = content;
                } else {
                    this.elements.aiInterpretationContent.innerHTML = `<div class="flex justify-center items-center py-8"><span class="spinner w-8 h-8 !border-t-purple-500 !border-gray-200"></span><span id="aiProgressMessage" class="ml-2 text-gray-600">Generating...</span></div>`;
                }
            }

            exportData() {
                if (!this.isSimulationFinished) {
                    alert("Please run a simulation to completion before exporting data.");
                    return;
                }
            
                const dataToExport = {
                    simulationParameters: {
                        gridSize: this.simulator.N,
                        viscosity: this.simulator.viscosity,
                        dt: this.simulator.dt,
                        totalSteps: this.totalSimSteps,
                        initialCondition: this.elements.paramInitCondition.value,
                    },
                    metricsHistory: this.metricsHistory,
                    finalMetrics: {
                        kineticEnergy: this.metricsHistory.ke.slice(-1)[0] || 0,
                        enstrophy: this.metricsHistory.enstrophy.slice(-1)[0] || 0,
                        helicity: this.metricsHistory.helicity.slice(-1)[0] || 0,
                        maxVelocity: this.maxMetrics.maxVel,
                        maxVorticity: this.maxMetrics.maxVort,
                    },
                    current2DSlice: {
                        variable: this.currentSliceData.variable,
                        axis: this.currentSliceData.axis,
                        index: this.currentSliceData.index,
                        data: this.currentSliceData.data ? Array.from(this.currentSliceData.data, row => Array.from(row)) : null // Convert Float32Array to regular array
                    }
                };
            
                const blob = new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `fluid_sim_data_N${this.simulator.N}_${new Date().toISOString()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            playConversationAudio() {
                const audio = this.elements.navierStokesAudio;
                const btn = this.elements.btnConversation;
                if (audio.paused) { audio.play(); btn.textContent = `Pause Conversation`; } 
                else { audio.pause(); btn.textContent = `Conversation`; }
                audio.onended = () => { btn.textContent = `Conversation`; };
            }

            showModal(modalId, sectionId = null) {
                const modal = document.getElementById(modalId);
                modal.style.display = 'flex';
                if (window.MathJax?.typesetPromise) window.MathJax.typesetPromise([modal]);
                if (sectionId) document.getElementById(sectionId)?.scrollIntoView({ behavior: 'smooth' });
            }

            hideAllModals() {
                document.querySelectorAll('.modal').forEach(m => m.style.display = 'none');
            }

            updateButtonStates() {
                const setButtonState = (btn, enabled) => {
                    if (btn) {
                        btn.disabled = !enabled;
                        btn.classList.toggle('opacity-50', !enabled);
                        btn.classList.toggle('cursor-not-allowed', !enabled);
                    }
                };
                const setGroupState = (controls, enabled) => {
                    controls.forEach(control => setButtonState(control, enabled));
                };
            
                const hasData = this.currentSimStep > 0;
                const canInterpret = this.isSimulationFinished && this.geminiApiKey.length > 0;
                const playbackControls = this.elements.playbackControls;
                const playbackSlider = this.elements.playbackSlider;
            
                if (this.isSimulationRunning) { // RUNNING STATE
                    setGroupState(this.parameterControls, false);
                    setGroupState(this.presetButtons, false);
                    setButtonState(this.elements.btnRun, true); // It's the STOP button
                    setButtonState(this.elements.btnPauseResume, true);
                    setButtonState(this.elements.btnRefresh, false);
                    setButtonState(this.elements.btnExport, false);
                    setButtonState(this.elements.btnResults, false);
                    setButtonState(this.elements.btnInterpretKids, false);
                    setButtonState(this.elements.btnQA, false);
            
                    if (playbackControls) {
                        playbackControls.classList.add('playback-disabled');
                        playbackSlider.disabled = true;
                    }
            
                } else if (this.isSimulationFinished) { // FINISHED STATE
                    setGroupState(this.parameterControls, false);
                    setGroupState(this.presetButtons, false);
                    setButtonState(this.elements.btnRun, false);
                    setButtonState(this.elements.btnPauseResume, false);
                    setButtonState(this.elements.btnRefresh, true);
                    setButtonState(this.elements.btnExport, true);
                    setButtonState(this.elements.btnResults, canInterpret);
                    setButtonState(this.elements.btnInterpretKids, canInterpret);
                    setButtonState(this.elements.btnQA, canInterpret);
            
                    if (playbackControls && hasData) {
                        playbackControls.classList.remove('playback-disabled');
                        playbackSlider.disabled = false;
                    } else if (playbackControls) {
                        playbackControls.classList.add('playback-disabled');
                        playbackSlider.disabled = true;
                    }
            
                } else { // READY STATE
                    setGroupState(this.parameterControls, true);
                    setGroupState(this.presetButtons, true);
                    setButtonState(this.elements.btnRun, true);
                    setButtonState(this.elements.btnPauseResume, false);
                    setButtonState(this.elements.btnRefresh, true);
                    setButtonState(this.elements.btnExport, false);
                    // AI buttons disabled because no data yet
                    setButtonState(this.elements.btnResults, false);
                    setButtonState(this.elements.btnInterpretKids, false);
                    setButtonState(this.elements.btnQA, false);
            
                    if (playbackControls) {
                        playbackControls.classList.add('playback-disabled');
                        playbackSlider.disabled = true;
                    }
                }

                const enableReplay = this.isSimulationFinished && this.simulationSnapshots.length > 0;
                setButtonState(this.elements.btnReplay, enableReplay);
                if (!enableReplay && this.replayAnimationTimer) {
                    this.toggleReplayAnimation();
                }
            
                // --- Update Button Appearance ---
                this.elements.btnRun.classList.toggle('bg-red-600', this.isSimulationRunning);
                this.elements.btnRun.classList.toggle('hover:bg-red-700', this.isSimulationRunning);
                this.elements.btnRun.classList.toggle('bg-indigo-600', !this.isSimulationRunning);
                this.elements.btnRun.classList.toggle('hover:bg-indigo-700', !this.isSimulationRunning);
                
                if (this.isSimulationRunning) {
                    this.elements.btnRunContent.innerHTML = `<svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0zM9 10h6v4H9v-4z"></path></svg> Stop`;
                    this.elements.btnRun.title = 'Stop Simulation';
                } else {
                    this.elements.btnRunContent.innerHTML = `<svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197 2.132A1 1 0 0110 13.82V9.18a1 1 0 011.555-.832l3.197 2.132a1 1 0 010 1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg> Simulation`;
                    this.elements.btnRun.title = 'Start Simulation';
                }
                
                if (this.isSimulationPaused) {
                    this.elements.btnPauseResume.innerHTML = `<svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168L10 9.18v5.64l4.752-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg> Resume`;
                    this.elements.btnPauseResume.title = 'Resume Simulation';
                } else {
                    this.elements.btnPauseResume.innerHTML = `<svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg> Pause`;
                    this.elements.btnPauseResume.title = 'Pause Simulation';
                }
                
                this.elements.btnRunContent.classList.toggle('pulsing-text', this.isSimulationRunning && !this.isSimulationPaused);
                
                // --- Update Status Indicators ---
                this.elements.simulationActivityIndicator.style.display = (this.isSimulationRunning && !this.isSimulationPaused) ? 'flex' : 'none';
                this.elements.liveSimSubtitle.innerHTML = (this.isSimulationRunning && !this.isSimulationPaused) ? '<span class="text-green-600-custom">ACTIVE</span>' : this.isSimulationFinished ? '<span class="text-blue-500">COMPLETED</span>' : '<span class="text-red-500">INACTIVE</span>';

                const enableSlicePlayer = this.isSimulationFinished;
                setButtonState(this.elements.btnSlicePlayPause, enableSlicePlayer);
                if (!enableSlicePlayer && this.sliceAnimationTimer) {
                    this.toggleSliceAnimation();
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new SimulationDashboard();
        });
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>