<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Fluid Dynamics Simulator v52.2</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js and OrbitControls CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Chart.js CDN for plotting -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <!-- MathJax Configuration (IMPORTANT for inline LaTeX) -->
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']] // Configure $ for inline math
          },
          svg: {
            fontCache: 'global' // Optimize font loading
          },
          options: {
            skipHtmlTags: ['script', 'noscript', 'textarea', 'pre', 'code', 'annotation', 'annotation-xml'],
            ignoreHtmlClass: 'no-mathjax' // Also ignore elements with this class
          }
        };
    </script>
    <!-- MathJax CDN for LaTeX rendering -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* Custom styles for better slider appearance */
        input[type='range']::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4F46E5; /* Indigo-600 */
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.3); /* Indigo-600 with opacity */
            margin-top: -6px; /* Adjust to center thumb on track */
        }
        input[type='range']::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4F46E5;
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.3);
        }

        /* Dynamic gradient for the slider track */
        input[type='range'] {
            -webkit-appearance: none; /* Override default browser styles */
            appearance: none;
            width: 100%;
            height: 4px; /* Height of the track */
            border-radius: 2px;
            outline: none; /* Remove focus outline */
            background: linear-gradient(to right,
                hsl(120, 60%, 85%) 0%,    /* Light Pastel Green */
                hsl(210, 70%, 75%) 33%,   /* Pastel Blue */
                hsl(270, 80%, 65%) 66%,   /* Pastel Purple */
                hsl(0, 90%, 55%) 100%     /* Pastel Red */
            );
            background-size: var(--slider-value-percent, 0%) 100%; /* Controls the fill amount */
            background-repeat: no-repeat;
            background-color: #E0E7FF; /* Color for the unfilled part of the track */
            transition: background-size 0.1s ease-out; /* Smooth transition for the gradient fill */
        }

        input[type='range']::-webkit-slider-runnable-track { background: transparent; }
        input[type='range']::-moz-range-track { background: transparent; }

        select {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='currentColor'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd'/%3E%3C/svg%3E");
            background-repeat: no-repeat; background-position: right 0.75rem center; background-size: 1.5em 1.5em; padding-right: 2.5rem;
        }

        /* Modal specific styles */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); justify-content: center; align-items: center; }
        .modal-content { background-color: #fefefe; margin: auto; padding: 20px; border-radius: 0.75rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); position: relative; max-width: 90%; max-height: 90%; overflow-y: auto; animation: fadeIn 0.3s ease-out; }
        .close-button { color: #aaa; float: right; font-size: 28px; font-weight: bold; position: absolute; top: 10px; right: 20px; }
        .close-button:hover, .close-button:focus { color: black; text-decoration: none; cursor: pointer; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }

        /* Spinner and Activity Indicator styles */
        .spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-top: 4px solid #fff; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; display: inline-block; vertical-align: middle; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes pulseColor { 0% { color: white; } 50% { color: #FECACA; } 100% { color: white; } }
        .pulsing-text { animation: pulseColor 1s ease-in-out infinite; }
        #simulationActivityIndicator { display: none; position: absolute; top: 1.5rem; right: 1.5rem; z-index: 10; display: flex; align-items: center; gap: 0.5rem; }
        .spinner.spinner-completed { animation: none; border-top-color: #10B981 !important; border-left-color: #10B981 !important; border-right-color: #10B981 !important; border-bottom-color: #10B981 !important; }

        /* Progress Bar styles */
        .progress-bar-container { position: relative; width: 100%; height: 0.625rem; background-color: #E0E7FF; border-radius: 9999px; margin-bottom: 1rem; overflow: hidden; }
        #progressBar { position: absolute; left: 0; top: 0; height: 100%; border-radius: 9999px; background-color: #4F46E5; transition: width 0.1s ease-out; }

        /* Dynamic Tooltip styles */
        #dynamicTooltip { position: absolute; background-color: rgba(31, 41, 55, 0.95); color: white; padding: 0.5rem 0.75rem; border-radius: 0.375rem; font-size: 0.75rem; line-height: 1rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); white-space: normal; max-width: 250px; z-index: 2000; pointer-events: none; opacity: 0; transition: opacity 0.2s ease-in-out; top: -9999px; left: -9999px; }
        #dynamicTooltip.show { opacity: 1; }

        /* 3D Visualization Container */
        #threeJsContainer { width: 100%; height: 500px; background-color: #f0f0f0; border-radius: 0.5rem; overflow: hidden; cursor: grab; position: relative; }
        #threeJsContainer:active { cursor: grabbing; }

        /* Color Legend Styles */
        .color-legend-container { display: flex; align-items: center; justify-content: space-between; width: 100%; margin-bottom: 1rem; padding: 0.5rem 0; font-size: 0.875rem; color: #374151; }
        .color-gradient { flex-grow: 1; height: 16px; background: linear-gradient(to right, hsl(120, 90%, 60%), hsl(60, 90%, 60%), hsl(0, 90%, 60%)); border-radius: 8px; margin: 0 0.5rem; box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }
        .legend-label { white-space: nowrap; font-weight: 500; }

        .text-green-600-custom { color: #16A34A; }

        /* Style for disabled playback controls */
        .playback-disabled {
            opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>
<body class="bg-gray-50 font-sans antialiased text-gray-800 p-4 sm:p-6">

    <div class="max-w-7xl mx-auto">
        <div class="text-center mb-4">
            <h1 class="font-bold tracking-widest text-gray-600" style="font-size: 10pt;"><span style="color: #FF0000;">Q</span> <span style="color: #0000FF;">U</span> A N T U M &nbsp; Q &nbsp; | &nbsp; R E S E A R C H &nbsp;&nbsp; &amp; &nbsp;&nbsp; D E V E L O P M E N T &nbsp;&nbsp; D I V I S I O N &nbsp; | &nbsp; 2 0 2 5 &copy;</h1>
        </div>
    </div>

    <div class="max-w-7xl mx-auto bg-white shadow-lg rounded-xl p-6 sm:p-8 border border-gray-200" id="mainContentArea">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-center text-indigo-700 mb-2">3D Fluid Dynamics Simulator</h1>
        <p class="text-center text-sm text-red-600 font-semibold mb-8">
            (A Conceptual 3D Incompressible Fluid Dynamics Model)
        </p>

        <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-md relative mb-8 text-center" role="alert">
            <strong class="font-bold">CRITICAL NOTE FOR RESEARCHERS:</strong>
            <span class="block sm:inline">This simulator provides a **conceptual visualization** of 3D incompressible fluid dynamics. It is **NOT** a direct, high-fidelity simulation of the 3D Navier-Stokes equations and cannot be used to prove or disprove the Navier-Stokes existence and smoothness conjecture. Its purpose is for conceptual understanding of related phenomena.</span>
        </div>

        <div class="flex flex-col lg:flex-row gap-6">
            <!-- Left Panel: Parameters and Controls -->
            <div class="lg:w-2/5 bg-gray-50 p-6 rounded-lg border border-gray-200 shadow-md" id="parameterSection">
                <h2 class="text-2xl font-bold text-gray-700 mb-6">Simulation Parameters</h2>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-y-6 gap-x-4 mb-8">
                    <!-- Grid Resolution -->
                    <div>
                        <label for="paramGridSize" class="block text-sm font-medium text-gray-600 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Grid Resolution (N)</p><p class='text-xs mb-2 text-gray-300'>The number of discrete points along each axis (NxNxN). Higher N provides higher spatial resolution but is computationally intensive.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>Total cells = $N^3$</p></div>">Grid Resolution (N):</label>
                        <div class="flex items-center gap-x-3 mt-1">
                            <input type="range" id="paramGridSize" min="8" max="32" step="4" value="16" class="w-full">
                            <input type="number" id="inputGridSize" min="8" max="32" step="4" value="16" class="bg-white p-1 border border-gray-300 rounded-md shadow-sm text-sm text-center" style="width: 5rem;">
                        </div>
                    </div>
                    <!-- Kinematic Viscosity -->
                    <div>
                        <label for="paramViscosity" class="block text-sm font-medium text-gray-600 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Kinematic Viscosity ($\nu$)</p><p class='text-xs mb-2 text-gray-300'>Controls fluid friction and energy dissipation. Higher $\nu$ leads to smoother, more stable flows.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>Term: $\nu \nabla^2 \mathbf{u}$</p></div>">Kinematic Viscosity ($\nu$):</label>
                        <div class="flex items-center gap-x-3 mt-1">
                            <input type="range" id="paramViscosity" min="0.001" max="0.1" step="0.001" value="0.01" class="w-full">
                            <input type="number" id="inputViscosity" min="0.001" max="0.1" step="0.001" value="0.010" class="bg-white p-1 border border-gray-300 rounded-md shadow-sm text-sm text-center" style="width: 5rem;">
                        </div>
                    </div>
                    <!-- Time Step -->
                    <div>
                        <label for="paramDt" class="block text-sm font-medium text-gray-600 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Time Step ($\Delta t$)</p><p class='text-xs mb-2 text-gray-300'>The duration of each simulation step. Smaller values increase accuracy but take longer.</p></div>">Time Step ($\Delta t$):</label>
                        <div class="flex items-center gap-x-3 mt-1">
                            <input type="range" id="paramDt" min="0.001" max="0.1" step="0.001" value="0.01" class="w-full">
                            <input type="number" id="inputDt" min="0.001" max="0.1" step="0.001" value="0.010" class="bg-white p-1 border border-gray-300 rounded-md shadow-sm text-sm text-center" style="width: 5rem;">
                        </div>
                    </div>
                     <!-- Simulation Duration -->
                    <div>
                        <label for="paramSimTime" class="block text-sm font-medium text-gray-600 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Simulation Steps</p><p class='text-xs mb-2 text-gray-300'>Total number of time steps to run the simulation for.</p></div>">Simulation Steps:</label>
                        <div class="flex items-center gap-x-3 mt-1">
                            <input type="range" id="paramSimTime" min="100" max="2000" step="100" value="500" class="w-full">
                            <input type="number" id="inputSimTime" min="100" max="2000" step="100" value="500" class="bg-white p-1 border border-gray-300 rounded-md shadow-sm text-sm text-center" style="width: 5rem;">
                        </div>
                    </div>
                    <!-- Initial Condition -->
                    <div class="col-span-full flex flex-col">
                        <label for="paramInitCondition" class="text-sm font-medium text-gray-600 mb-1 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Initial Condition</p><p class='text-xs text-gray-300'>The starting state of the fluid at time $t=0$.</p></div>">Initial Condition:</label>
                        <select id="paramInitCondition" class="bg-white block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-base h-10">
                            <option value="vortex">Single Vortex</option>
                            <option value="jet">Central Jet</option>
                            <option value="random">Random Noise</option>
                        </select>
                    </div>
                    <!-- Visualization Mode -->
                    <div class="col-span-full flex flex-col">
                        <label for="paramVisualization" class="text-sm font-medium text-gray-600 mb-1 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Visualization Mode</p><p class='text-xs text-gray-300'>Selects which physical quantity to display in the 3D view.</p></div>">Visualization Mode:</label>
                        <select id="paramVisualization" class="bg-white block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-base h-10">
                            <option value="velocity">Velocity Vectors</option>
                            <option value="density">Density (Passive Scalar)</option>
                            <option value="vorticity">Vorticity Magnitude</option>
                        </select>
                    </div>
                    <!-- Enable Tooltips Checkbox -->
                    <div class="col-span-full flex items-center mt-4">
                        <input type="checkbox" id="enableTooltips" class="form-checkbox h-4 w-4 text-indigo-600 transition duration-150 ease-in-out rounded-md cursor-pointer">
                        <label for="enableTooltips" class="ml-2 text-sm font-medium text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Enable Tooltips</p><p class='text-xs text-gray-300'>Toggle dashboard-wide tooltips for mathematical equations and important labels.</p></div>">Enable Equation Tooltips</label>
                    </div>
                </div>

                <!-- Simulation Presets -->
                <div class="mt-6">
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Simulation Presets:</h3>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
                        <button id="presetStableFlow" class="px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Preset: Stable Flow</p><p class='text-xs text-gray-300'>Demonstrates a stable, high-viscosity flow where initial energy dissipates smoothly.</p></div>">Stable Flow</button>
                        <button id="presetTurbulence" class="px-4 py-2 bg-red-600 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Preset: Turbulence</p><p class='text-xs text-gray-300'>Highlights low-viscosity conditions leading to complex, chaotic, turbulent-like behavior.</p></div>">Turbulence</button>
                        <button id="presetVortexStretching" class="px-4 py-2 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Preset: Vortex Stretching</p><p class='text-xs text-gray-300'>Visualizes the advection and intensification of a vortex structure, a key mechanism in turbulence.</p></div>">Vortex Stretching</button>
                        <button id="presetDensityTransport" class="px-4 py-2 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Preset: Density Transport</p><p class='text-xs text-gray-300'>Shows how a passive scalar (like dye) is transported and mixed by the fluid flow.</p></div>">Density Transport</button>
                    </div>
                </div>

                <!-- Simulation Controls -->
                <h3 class="text-lg font-semibold text-gray-700 mt-6 mb-3">Simulation Controls:</h3>
                <div class="flex flex-col sm:flex-row justify-around gap-4 mb-4">
                    <button id="btnRun" class="flex-1 px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10 cursor-pointer" title="Start Simulation">
                        <span id="btnRunContent" class="flex items-center justify-center">
                            <svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197 2.132A1 1 0 0110 13.82V9.18a1 1 0 011.555-.832l3.197 2.132a1 1 0 010 1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                            Simulation
                        </span>
                    </button>
                    <button id="btnPauseResume" class="flex-1 px-4 py-2 bg-yellow-500 text-white font-semibold rounded-lg shadow-md hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-offset-2 transition ease-in-out duration-150 opacity-50 cursor-not-allowed h-10" disabled title="Pause Simulation">
                        <svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg> Simulation
                    </button>
                </div>
                <div class="flex flex-col sm:flex-row justify-around gap-4">
                    <button id="btnRefresh" class="flex-1 px-4 py-2 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10 cursor-pointer" title="Refresh Dashboard">
                        <svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004 12c0 2.21.817 4.231 2.105 5.786M20 20v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
                        Refresh
                    </button>
                    <button id="btnExport" class="flex-1 px-4 py-2 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition ease-in-out duration-150 opacity-50 cursor-not-allowed h-10" disabled title="Export Data">
                        <svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"></path></svg>
                        Export Data
                    </button>
                </div>
                <div class="flex justify-around gap-4 mt-4">
                    <button id="btnHelp" class="flex-1 px-4 py-2 bg-gray-600 text-white font-semibold rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10 flex items-center justify-center cursor-pointer" title="How to Interpret the Dashboard">
                        How to Interpret this Dashboard
                    </button>
                </div>
            </div>

            <!-- Right Panel: Live Visualization -->
            <div class="lg:w-3/5 bg-gray-50 p-6 rounded-lg border border-gray-200 shadow-md relative">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold text-gray-700">Live Simulation <span id="liveSimSubtitle" class="ml-2 text-base font-semibold"></span></h2>
                    <div id="simulationActivityIndicator" class="hidden">
                        <span id="percentageCounter" class="text-sm font-semibold text-gray-700">0%</span>
                        <span class="spinner w-8 h-8 !border-t-green-500 !border-gray-300"></span>
                    </div>
                </div>
                <div class="progress-bar-container">
                    <div id="progressBar" class="bg-indigo-600 h-full rounded-full transition-all duration-100 ease-out" style="width: 0%;"></div>
                </div>
                 <!-- Color Legend for 3D Visualization -->
                <div class="color-legend-container">
                    <span class="legend-label left">Low Vorticity</span>
                    <div class="color-gradient"></div>
                    <span class="legend-label right">High Vorticity</span>
                </div>
                <div id="threeJsContainer" class="relative bg-gray-200 rounded-lg shadow-inner border border-gray-300">
                     <p id="performanceWarning" class="absolute top-2 left-2 text-xs text-red-500 bg-black bg-opacity-50 p-1 rounded hidden z-10">
                        High grid resolution may cause slowdowns.
                    </p>
                </div>
                <!-- Simulation Playback Controls -->
                <div id="playbackControls" class="mt-4 bg-white rounded-lg p-4 shadow-inner border border-gray-300 playback-disabled">
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Simulation Playback</h3>
                    <input type="range" id="playbackSlider" min="0" max="1" step="1" value="0" class="w-full" disabled>
                    <div class="flex justify-between text-xs text-gray-500 mt-1">
                        <span id="playbackCurrentTime">Step: 0</span>
                        <span id="playbackTotalTime">Total: 0</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Simulation Metrics Section -->
        <div class="mt-8 bg-gray-50 p-6 rounded-lg border border-gray-200 shadow-md">
            <h2 class="text-2xl font-bold text-gray-700 mb-6">Simulation Metrics</h2>
            <div id="metricsContent" class="p-4 bg-white rounded-b-lg shadow-inner border border-gray-300">
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-4">
                    <div>
                        <h3 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Kinetic Energy ($E_k$)</p><p class='text-xs mb-2 text-gray-300'>The total energy of motion in the fluid. Tends to decay over time due to viscosity.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$E_k = \frac{1}{2} \int |\mathbf{u}|^2 dV$</p></div>">Kinetic Energy ($E_k$):</h3>
                        <p class="text-gray-600">Current: <span id="metricKE_current" class="font-mono">0.0000</span></p>
                        <p class="text-gray-600">Max Overall: <span id="metricKE_max" class="font-mono">0.0000</span></p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Enstrophy ($\mathcal{E}$)</p><p class='text-xs mb-2 text-gray-300'>The intensity of vorticity (swirling motion). High enstrophy is a hallmark of turbulence.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$\mathcal{E} = \frac{1}{2} \int |\omega|^2 dV$</p></div>">Enstrophy ($\mathcal{E}$):</h3>
                        <p class="text-gray-600">Current: <span id="metricEnstrophy_current" class="font-mono">0.0000</span></p>
                        <p class="text-gray-600">Max Overall: <span id="metricEnstrophy_max" class="font-mono">0.0000</span></p>
                    </div>
                     <div>
                        <h3 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Helicity ($\mathcal{H}$)</p><p class='text-xs mb-2 text-gray-300'>Measures the 'knottedness' of vortex lines. Important for characterizing turbulent structures.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$\mathcal{H} = \int \mathbf{u} \cdot \omega \, dV$</p></div>">Helicity ($\mathcal{H}$):</h3>
                        <p class="text-gray-600">Current: <span id="metricHelicity_current" class="font-mono">0.0000</span></p>
                        <p class="text-gray-600">Max Overall: <span id="metricHelicity_max" class="font-mono">0.0000</span></p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Max Velocity ($|\mathbf{u}|_{max}$)</p><p class='text-xs mb-2 text-gray-300'>The highest speed found anywhere in the fluid domain at the current time.</p></div>">Max Velocity:</h3>
                        <p class="text-gray-600">Current: <span id="metricMaxVel_current" class="font-mono">0.000</span></p>
                        <p class="text-gray-600">Max Overall: <span id="metricMaxVel_max" class="font-mono">0.000</span></p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Max Vorticity ($|\omega|_{max}$)</p><p class='text-xs mb-2 text-gray-300'>The strongest local rotation in the fluid. A key value for studying potential singularities.</p></div>">Max Vorticity:</h3>
                        <p class="text-gray-600">Current: <span id="metricMaxVort_current" class="font-mono">0.000</span></p>
                        <p class="text-gray-600">Max Overall: <span id="metricMaxVort_max" class="font-mono">0.000</span></p>
                    </div>
                    <div class="col-span-1 md:col-span-1 lg:col-span-1">
                        <h3 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Average Divergence ($|\nabla \cdot \mathbf{u}|$)</p><p class='text-xs mb-2 text-gray-300'>Measures numerical error in preserving the incompressibility condition. Should be close to zero.</p></div>">Average Divergence:</h3>
                        <p class="text-gray-600">Current: <span id="metricAvgDiv_current" class="font-mono">0.0000</span></p>
                    </div>
                </div>
                <h3 class="font-semibold text-gray-700 mb-2">Time Series Plots:</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div class="w-full bg-gray-100 rounded-md border border-gray-300 p-2 relative">
                        <canvas id="keChartCanvas" class="w-full h-48"></canvas>
                    </div>
                    <div class="w-full bg-gray-100 rounded-md border border-gray-300 p-2 relative">
                        <canvas id="enstrophyChartCanvas" class="w-full h-48"></canvas>
                    </div>
                    <div class="w-full bg-gray-100 rounded-md border border-gray-300 p-2 relative">
                        <canvas id="helicityChartCanvas" class="w-full h-48"></canvas>
                    </div>
                    <div class="w-full bg-gray-100 rounded-md border border-gray-300 p-2 relative">
                        <canvas id="maxVortChartCanvas" class="w-full h-48"></canvas>
                    </div>
                </div>

                <div class="flex flex-col items-center mt-6">
                    <div class="grid grid-cols-2 gap-4 w-full max-w-md">
                        <button id="btnResults" class="px-6 py-3 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10 cursor-pointer" disabled title="Interpret Current Simulation State">
                            <span class="flex items-center justify-center">✨ Results</span>
                        </button>
                        <button id="btnInterpretKids" class="px-6 py-3 bg-blue-400 text-white font-semibold rounded-lg shadow-md hover:bg-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-300 focus:ring-offset-2 transition ease-in-out duration-150 h-10 cursor-pointer" disabled title="Ask Einstein for a simple explanation">
                            <span class="flex items-center justify-center">✨ Ask Einstein</span>
                        </button>
                        <button id="btnQA" class="px-6 py-3 bg-orange-500 text-white font-semibold rounded-lg shadow-md hover:bg-orange-600 focus:outline-none focus:ring-2 focus:ring-orange-400 focus:ring-offset-2 transition ease-in-out duration-150 h-10 cursor-pointer" disabled title="Generate Questions & Answers">
                            <span class="flex items-center justify-center">✨ Q&A</span>
                        </button>
                        <button id="btnConversation" class="px-6 py-3 bg-emerald-500 text-white font-semibold rounded-lg shadow-md hover:bg-emerald-600 focus:outline-none focus:ring-2 focus:ring-emerald-400 focus:ring-offset-2 transition ease-in-out duration-150 h-10 flex items-center justify-center cursor-pointer" title="Listen to a conversation about Navier-Stokes">
                            Conversation
                        </button>
                        <audio id="navierStokesAudio" src="https://quantumq-ai.github.io/QQ_1D_Navier_Stokes_Conjecture_Simulator/NavierStokesConversation.mp3" preload="auto"></audio>
                    </div>
                    <div class="mt-4 w-full max-w-md text-center">
                        <input type="password" id="geminiApiKeyInput" placeholder="Enter Gemini API Key to enable interpretation" class="bg-white w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-purple-500 focus:border-purple-500 text-sm text-center">
                        <p class="text-xs text-gray-600 mt-2">INTERNET CONNECTION REQUIRED TO USE AI INTEGRATION</p>
                        <a href="#" id="getApiKeyLink" class="font-bold text-blue-600 hover:text-blue-800 text-xs no-underline mt-2 inline-block cursor-pointer">HOW TO ACQUIRE A GEMINI KEY</a>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tabbed Results Section -->
        <div class="mt-8 bg-gray-50 p-6 rounded-lg border border-gray-200 shadow-md">
            <h2 class="text-2xl font-bold text-gray-700 mb-6">Detailed Analysis</h2>
            <div class="flex border-b border-gray-200">
                <button id="tabAnalysis" class="px-4 py-2 text-sm font-medium text-indigo-600 border-b-2 border-indigo-600 focus:outline-none transition duration-150 ease-in-out cursor-pointer">Distribution Analysis</button>
            </div>
            <div id="detailedResultsContent" class="p-4 bg-white rounded-b-lg shadow-inner border border-gray-300">
                <div id="derivedMetricsWrapper" class="hidden mb-8">
                    <h3 class="text-lg font-semibold text-gray-700 mb-4">Derived Physical Quantities (at final state):</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        <!-- Reynolds Number -->
                        <div class="bg-gray-100 p-4 rounded-lg border border-gray-200 shadow-sm">
                            <h4 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Reynolds Number ($Re$)</p><p class='text-xs mb-2 text-gray-300'>A dimensionless number indicating the flow regime. Low Re signifies laminar flow, high Re signifies turbulent flow.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$Re = \frac{UL}{\nu} \approx \frac{\sqrt{2 E_k}}{\nu}$</p></div>">Reynolds Number ($Re$)</h4>
                            <p id="metricRe" class="font-mono text-2xl text-indigo-600 mt-1">0.00</p>
                            <p class="text-xs text-gray-500 mt-2">Ratio of inertial to viscous forces. Higher values suggest more turbulent-like flow.</p>
                        </div>
                        <!-- Taylor Reynolds Number -->
                        <div class="bg-gray-100 p-4 rounded-lg border border-gray-200 shadow-sm">
                            <h4 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Taylor Reynolds Number ($Re_{\lambda}$)</p><p class='text-xs mb-2 text-gray-300'>A Reynolds number based on the Taylor microscale, characterizing small-scale turbulence.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$Re_{\lambda} = \frac{\sqrt{2} E_k}{\nu \sqrt{\mathcal{E}}}$</p></div>">Taylor Reynolds Number ($Re_{\lambda}$)</h4>
                            <p id="metricReTaylor" class="font-mono text-2xl text-indigo-600 mt-1">0.00</p>
                            <p class="text-xs text-gray-500 mt-2">Characterizes turbulence at intermediate scales, where vortex stretching is significant.</p>
                        </div>
                        <!-- Energy Dissipation Rate -->
                        <div class="bg-gray-100 p-4 rounded-lg border border-gray-200 shadow-sm">
                            <h4 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Energy Dissipation ($\epsilon$)</p><p class='text-xs mb-2 text-gray-300'>The rate at which kinetic energy is converted to thermal energy by viscosity.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$\epsilon = 2\nu\mathcal{E}$</p></div>">Energy Dissipation ($\epsilon$)</h4>
                            <p id="metricEpsilon" class="font-mono text-2xl text-red-600 mt-1">0.00</p>
                            <p class="text-xs text-gray-500 mt-2">Rate of energy loss due to fluid friction. Measured in $m^2/s^3$.</p>
                        </div>
                        <!-- Kolmogorov Length Scale -->
                        <div class="bg-gray-100 p-4 rounded-lg border border-gray-200 shadow-sm">
                            <h4 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Kolmogorov Scale ($\eta$)</p><p class='text-xs mb-2 text-gray-300'>The smallest length scale in a turbulent flow, where dissipation occurs.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$\eta = (\nu^3 / \epsilon)^{1/4}$</p></div>">Kolmogorov Scale ($\eta$)</h4>
                            <p id="metricEta" class="font-mono text-2xl text-green-700 mt-1">0.00</p>
                            <p class="text-xs text-gray-500 mt-2">The smallest eddies where energy dissipates into heat. Measured in meters.</p>
                        </div>
                        <!-- Integral Length Scale -->
                        <div class="bg-gray-100 p-4 rounded-lg border border-gray-200 shadow-sm">
                            <h4 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Integral Scale ($L_{int}$)</p><p class='text-xs mb-2 text-gray-300'>An estimate of the size of the largest eddies in the flow.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>$L_{int} \approx \frac{(E_k)^{3/2}}{\epsilon}$</p></div>">Integral Scale ($L_{int}$)</h4>
                            <p id="metricLInt" class="font-mono text-2xl text-blue-600 mt-1">0.00</p>
                            <p class="text-xs text-gray-500 mt-2">The size of the largest, energy-containing eddies in the flow. Measured in meters.</p>
                        </div>
                        <!-- Resolution Ratio -->
                        <div class="bg-gray-100 p-4 rounded-lg border border-gray-200 shadow-sm">
                            <h4 class="font-semibold text-gray-700 cursor-pointer" data-tooltip-content="<div class='text-left'><p class='font-semibold mb-1'>Resolution Ratio ($\Delta x / \eta$)</p><p class='text-xs mb-2 text-gray-300'>Compares grid spacing to the smallest turbulent scale. Values > 1 suggest under-resolved turbulence.</p><p class='font-mono text-center bg-gray-900 rounded p-1 text-sm'>Ratio = $\Delta x / \eta$</p></div>">Resolution Ratio ($\Delta x / \eta$)</h4>
                            <p id="metricDxEtaRatio" class="font-mono text-2xl text-purple-600 mt-1">0.00</p>
                            <p class="text-xs text-gray-500 mt-2">Measures if the grid is fine enough to capture the smallest eddies. > 1 is under-resolved.</p>
                        </div>
                    </div>
                </div>
                 <div id="analysisContentWrapper" class="hidden">
                    <h3 class="text-lg font-semibold text-gray-700 mb-2">Final State Distribution Plots:</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div class="w-full bg-gray-100 rounded-md border border-gray-300 p-2 relative">
                            <canvas id="velocityDistChartCanvas" class="w-full h-64"></canvas>
                        </div>
                        <div class="w-full bg-gray-100 rounded-md border border-gray-300 p-2 relative">
                            <canvas id="vorticityDistChartCanvas" class="w-full h-64"></canvas>
                        </div>
                         <div class="w-full bg-gray-100 rounded-md border border-gray-300 p-2 relative">
                            <canvas id="pressureDistChartCanvas" class="w-full h-64"></canvas>
                        </div>
                        <div class="w-full bg-gray-100 rounded-md border border-gray-300 p-2 relative">
                            <canvas id="helicityCosineDistChartCanvas" class="w-full h-64"></canvas>
                        </div>
                    </div>
                </div>
                <p id="analysisPlaceholder" class="text-gray-500 text-center py-8">Run a simulation to see detailed analysis and derived physical quantities here.</p>
            </div>
        </div>
    </div>
    
    <!-- Footer -->
    <footer class="mt-8 text-center text-xs text-gray-600" style="font-size: 9pt;">
        <p>
            Q U A N T U M &nbsp; Q &nbsp; P T E &nbsp; L T D
            <span class="mx-2">//</span> U E N &nbsp; 2 0 2 4 3 3 9 9 2 N
            <span class="mx-2">//</span> <a href="mailto:information@quantumq.net" class="text-blue-800 hover:text-indigo-600 cursor-pointer">✉️ E - M A I L</a>
            <span class="mx-2">//</span> <a href="#" id="acknowledgementsLink" class="hover:text-indigo-600 cursor-pointer">ACKNOWLEDGEMENTS</a>
            <span class="mx-2">//</span> <a href="#" id="legalLink" class="hover:text-indigo-600 cursor-pointer">LEGAL</a>
            <span class="mx-2">//</span> 2 0 2 5 &copy;
        </p>
    </footer>

    <!-- Modals (Help, Legal, and AI Interpretation) -->
    <div id="interpretationModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2 class="text-2xl font-bold text-gray-800 mb-4">How to Interpret this Dashboard</h2>
            
            <h3 class="text-xl font-semibold text-gray-700 mb-2">1. Understanding this Simulator's Purpose</h3>
            <p class="mb-4 text-gray-700">This simulator provides a **conceptual visualization** of **3D incompressible fluid dynamics**. It numerically solves a simplified form of the Navier-Stokes equations on a discrete grid, demonstrating how a fluid's velocity field ($\mathbf{u}$) and a passive scalar (like density or "dye") evolve over time due to advection (transport by flow) and diffusion (spreading).</p>
            <p class="mb-4 text-gray-700">
                The core equations being modeled are:
                <br>
                **Momentum Equation (simplified):**
                $$ \frac{\partial \mathbf{u}}{\partial t} + (\mathbf{u} \cdot \nabla)\mathbf{u} = -\frac{1}{\rho}\nabla p + \nu \nabla^2 \mathbf{u} $$
                **Incompressibility Condition:**
                $$ \nabla \cdot \mathbf{u} = 0 $$
                where:
                <ul class="list-disc list-inside ml-4 text-gray-700">
                    <li>$\mathbf{u}(x,y,z,t)$ is the fluid velocity vector field.</li>
                    <li>$p$ is the pressure, ensuring incompressibility.</li>
                    <li>$\nu$ is the kinematic viscosity, representing fluid friction.</li>
                </ul>
            </p>
            <div class="mt-4 mb-4 text-red-600 font-semibold border border-red-500 p-3 rounded-md">
                <strong class="underline">CRITICAL CLARIFICATION:</strong> This simulator uses a simplified numerical scheme for browser compatibility and conceptual demonstration. It is **NOT** a high-fidelity Computational Fluid Dynamics (CFD) tool suitable for rigorous quantitative analysis. Specifically, it **cannot be used to formally prove or disprove the Navier-Stokes existence and smoothness conjecture.** The conjecture concerns the analytical properties of solutions to the full, continuous equations, which requires advanced mathematical techniques beyond numerical simulation.
            </div>

            <h3 class="text-xl font-semibold text-gray-700 mb-2 mt-6">2. Simulation Parameters</h3>
            <ul class="list-disc list-inside ml-4 text-gray-700 space-y-2">
                <li><b>Grid Resolution (N):</b> The number of discrete points along each dimension (N x N x N). Higher N means finer resolution but significantly increases computational cost.</li>
                <li><b>Kinematic Viscosity ($\nu$):</b> Controls the fluid's resistance to flow. Higher $\nu$ leads to faster smoothing and more rapid dissipation of energy.</li>
                <li><b>Time Step ($\Delta t$):</b> The duration of each simulation step. Larger $\Delta t$ can speed up the simulation but may lead to numerical instability.</li>
                <li><b>Initial Condition:</b> The starting state of the fluid (e.g., a central vortex, a jet, or random noise).</li>
                 <li><b>Visualization Mode:</b> Selects what quantity is displayed: velocity vectors, density (passive dye), or vorticity (local spin).</li>
            </ul>

            <h3 class="text-xl font-semibold text-gray-700 mb-2 mt-6">3. Interpreting the Results</h3>
            <ul class="list-disc list-inside ml-4 text-gray-700 space-y-2">
                <li><b>3D Visualization:</b> Use your mouse to rotate (left-click), pan (right-click), and zoom (scroll wheel). Observe how flow patterns evolve. The color legend (green to red) indicates the local vorticity or "spin" intensity.</li>
                <li><b>Kinetic Energy, Enstrophy & Helicity:</b> These charts show the evolution of the fluid's total motion energy, total "spin" energy, and structural "knottedness". In a closed system, viscosity causes these to decay over time. The rate of decay and transient peaks provide insight into the flow dynamics (e.g., vortex stretching increasing enstrophy before dissipation).</li>
                <li><b>Distribution Analysis:</b> The histograms in the "Detailed Analysis" section show the statistical spread of velocity, vorticity, and pressure magnitudes, revealing the character of the flow (e.g., whether it is dominated by a few strong features or many weak ones).</li>
            </ul>
             
            <div id="apiKeyHelpSection">
                <h3 class="text-xl font-semibold text-gray-700 mb-2 mt-6">4. Acquiring a Gemini API Key</h3>
                <p class="mb-4 text-gray-700">To enable the AI-powered interpretation features (Results, Ask Einstein, Q&A), you need a Gemini API key. You can get a free key from Google AI Studio.</p>
                <ol class="list-decimal list-inside ml-4 text-gray-700 space-y-2">
                    <li>Visit the Google AI Studio website: <a href="https://aistudio.google.com/" target="_blank" class="text-blue-600 hover:underline">https://aistudio.google.com/</a></li>
                    <li>Sign in with your Google account.</li>
                    <li>Click the "Get API key" button and create a new API key.</li>
                    <li>Copy the key and paste it into the input box in the "Simulation Metrics" panel.</li>
                </ol>
            </div>

            <div id="acknowledgementsSection">
                <h3 class="text-xl font-semibold text-gray-700 mb-2 mt-6">5. Acknowledgements</h3>
                <p class="mb-4 text-gray-700">This simulator was built using a combination of powerful open-source technologies. We gratefully acknowledge the creators and maintainers of these projects:</p>
                <ul class="list-disc list-inside ml-4 text-gray-700 space-y-3">
                    <li><b>HTML5, CSS3, & JavaScript (ES6+):</b> The fundamental technologies of the web.</li>
                    <li><b>Tailwind CSS:</b> For rapid UI development. (<a href="https://opensource.org/licenses/MIT" target="_blank" class="text-blue-600">MIT License</a>)</li>
                    <li><b>Three.js:</b> For 3D rendering. (<a href="https://github.com/mrdoob/three.js/blob/dev/LICENSE" target="_blank" class="text-blue-600">MIT License</a>)</li>
                    <li><b>Chart.js:</b> For all data visualizations. (<a href="https://opensource.org/licenses/MIT" target="_blank" class="text-blue-600">MIT License</a>)</li>
                    <li><b>MathJax:</b> For beautiful LaTeX rendering. (<a href="https://www.apache.org/licenses/LICENSE-2.0" target="_blank" class="text-blue-600">Apache License 2.0</a>)</li>
                    <li><b>Google Gemini:</b> The advanced LLM that powers the AI-driven interpretation features.</li>
                </ul>
            </div>
        </div>
    </div>

    <div id="legalModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Legal Disclaimers & Terms of Use</h2>
            
            <h3 class="text-lg font-semibold text-gray-700 mb-2">1. Experimental Research Tool</h3>
            <p class="mb-4 text-gray-700 text-sm">
                This 1D Fluid Dynamics Analogue Simulator (the "Tool") is provided by Quantum Q PTE. LTD. ("Quantum Q") as an experimental research and educational tool. It is intended solely for use by the scientific, mathematical, and engineering communities for conceptual exploration and educational purposes. The Tool is not designed, certified, or intended for use in any commercial, industrial, clinical, or mission-critical applications.
            </p>

            <h3 class="text-lg font-semibold text-gray-700 mb-2">2. No Warranty</h3>
            <p class="mb-4 text-gray-700 text-sm">
                THE TOOL IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT. IN NO EVENT SHALL QUANTUM Q, ITS DIRECTORS, EMPLOYEES, OR AFFILIATES BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT, OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH THE TOOL OR THE USE OR OTHER DEALINGS IN THE TOOL.
            </p>

            <h3 class="text-lg font-semibold text-gray-700 mb-2">3. Limitation of Liability</h3>
            <p class="mb-4 text-gray-700 text-sm">
                You expressly understand and agree that Quantum Q shall not be liable for any direct, indirect, incidental, special, consequential, or exemplary damages, including but not limited to, damages for loss of profits, goodwill, use, data, or other intangible losses (even if Quantum Q has been advised of the possibility of such damages), resulting from the use or the inability to use the Tool. The entire risk as to the quality and performance of the Tool is with you. Should the Tool prove defective, you assume the cost of all necessary servicing, repair, or correction.
            </p>

            <h3 class="text-lg font-semibold text-gray-700 mb-2">4. No Guarantee of Accuracy</h3>
            <p class="mb-4 text-gray-700 text-sm">
                While efforts have been made to ensure the mathematical and numerical integrity of the simulation, Quantum Q makes no guarantee as to the accuracy, reliability, or completeness of the results generated by the Tool. The outputs are for illustrative and conceptual purposes only and should not be used for peer-reviewed publications, engineering design, or any other formal application without independent verification and validation. As stated prominently within the Tool, this simulator is an *analogue* and is not a direct simulation of the 3D Navier-Stokes equations.
            </p>

            <h3 class="text-lg font-semibold text-gray-700 mb-2">5. Intellectual Property</h3>
            <p class="mb-4 text-gray-700 text-sm">
                All rights, title, and interest in and to the Tool, including its source code, design, and branding, are the exclusive property of Quantum Q PTE. LTD. You may not copy, modify, distribute, sell, or lease any part of our Tool or its included software, nor may you reverse engineer or attempt to extract the source code of that software, unless laws prohibit those restrictions or you have our written permission.
            </p>

            <h3 class="text-lg font-semibold text-gray-700 mb-2">6. Governing Law & Jurisdiction</h3>
            <p class="mb-4 text-gray-700 text-sm">
                These terms shall be governed by and construed in accordance with the laws of the Republic of Singapore, without regard to its conflict of law provisions. Any disputes arising out of or in connection with these terms shall be subject to the exclusive jurisdiction of the courts of the Republic of Singapore.
            </p>
            
            <h3 class="text-lg font-semibold text-gray-700 mb-2">7. International Applicability and English Law</h3>
            <p class="mb-4 text-gray-700 text-sm">
                While the primary governing law is that of the Republic of Singapore, these terms are intended to be broadly applicable to users globally. For users in jurisdictions where English law is applicable or preferred, these terms shall be interpreted in a manner consistent with the general principles of English contract law, to the extent that such interpretation does not conflict with the mandatory laws of Singapore. The parties acknowledge and agree that the principles of common law and equity, as applied in English law, may be considered in interpreting these terms where Singapore law is silent or where such principles provide additional clarity, provided always that Singapore law remains the ultimate governing law.
            </p>

            <p class="text-gray-600 text-xs italic mt-6">By using this Tool, you acknowledge that you have read, understood, and agree to be bound by these terms and disclaimers.</p>
        </div>
    </div>

    <div id="aiInterpretationModal" class="modal">
        <div class="modal-content w-11/12 md:w-3/4 lg:w-1/2">
            <span class="close-button" id="closeAiInterpretationModal">&times;</span>
            <h2 class="text-2xl font-bold text-gray-800 mb-4">✨ AI Simulation Interpretation</h2>
            <div id="aiInterpretationContent" class="text-gray-700 prose max-w-none">
                <div class="flex justify-center items-center py-8">
                    <span class="spinner w-8 h-8 !border-t-purple-500 !border-gray-200"></span>
                    <span id="aiProgressMessage" class="ml-2 text-gray-600">Generating...</span>
                </div>
            </div>
            <p class="text-sm text-gray-500 mt-4 italic">
                (Interpretation provided by Gemini LLM. It is for conceptual understanding and does not constitute formal scientific analysis.)
            </p>
        </div>
    </div>

    <!-- Dynamic Tooltip Element (Hidden by default) -->
    <div id="dynamicTooltip" class="absolute z-50 p-2 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 transition-opacity duration-200 pointer-events-none"></div>
    
    <script type="importmap">
    {
      "imports": {
        "@google/generative-ai": "https://esm.sh/@google/generative-ai@0.14.0"
      }
    }
    </script>

    <script type="module">
        import { GoogleGenerativeAI } from "@google/generative-ai";

        // ==============================================================================
        // CLASS 1: THE 3D FLUID SIMULATION ENGINE
        // ==============================================================================
        class FluidSimulator3D {
            constructor(N, viscosity, dt) {
                this.N = N;
                this.size = N + 2;
                this.viscosity = viscosity;
                this.dt = dt;
                this.dx = 1.0 / N;

                this.u = this.create3DArray(); this.v = this.create3DArray(); this.w = this.create3DArray();
                this.u_prev = this.create3DArray(); this.v_prev = this.create3DArray(); this.w_prev = this.create3DArray();
                this.density = this.create3DArray(); this.density_prev = this.create3DArray();
                this.p = this.create3DArray(); this.div = this.create3DArray();
            }

            create3DArray() { return Array(this.size).fill(0).map(() => Array(this.size).fill(0).map(() => new Float32Array(this.size).fill(0))); }

            set_bnd(b, x) {
                for (let i = 1; i <= this.N; i++) {
                    for (let j = 1; j <= this.N; j++) {
                        x[0][i][j] = b == 1 ? -x[1][i][j] : x[1][i][j];
                        x[this.N + 1][i][j] = b == 1 ? -x[this.N][i][j] : x[this.N][i][j];
                        x[i][0][j] = b == 2 ? -x[i][1][j] : x[i][1][j];
                        x[i][this.N + 1][j] = b == 2 ? -x[i][this.N][j] : x[i][this.N][j];
                        x[i][j][0] = b == 3 ? -x[i][j][1] : x[i][j][1];
                        x[i][j][this.N + 1] = b == 3 ? -x[i][j][this.N] : x[i][j][this.N];
                    }
                }
                x[0][0][0] = 0.33 * (x[1][0][0] + x[0][1][0] + x[0][0][1]);
                x[0][this.N + 1][0] = 0.33 * (x[1][this.N + 1][0] + x[0][this.N][0] + x[0][this.N + 1][1]);
                x[this.N + 1][0][0] = 0.33 * (x[this.N][0][0] + x[this.N + 1][1][0] + x[this.N + 1][0][1]);
                x[this.N + 1][this.N + 1][0] = 0.33 * (x[this.N][this.N + 1][0] + x[this.N + 1][this.N][0] + x[this.N + 1][this.N + 1][1]);
                x[0][0][this.N + 1] = 0.33 * (x[1][0][this.N + 1] + x[0][1][this.N + 1] + x[0][0][this.N]);
                x[0][this.N + 1][this.N + 1] = 0.33 * (x[1][this.N + 1][this.N + 1] + x[0][this.N][this.N + 1] + x[0][this.N + 1][this.N]);
                x[this.N + 1][0][this.N + 1] = 0.33 * (x[this.N][0][this.N + 1] + x[this.N + 1][1][this.N + 1] + x[this.N + 1][0][this.N]);
                x[this.N + 1][this.N + 1][this.N + 1] = 0.33 * (x[this.N][this.N + 1][this.N + 1] + x[this.N + 1][this.N][this.N + 1] + x[this.N + 1][this.N + 1][this.N]);
            }
            
            lin_solve(b, x, x0, a, c) {
                const cRecip = 1.0 / c;
                for (let k = 0; k < 20; k++) {
                    for (let l = 1; l <= this.N; l++) {
                        for (let j = 1; j <= this.N; j++) {
                            for (let i = 1; i <= this.N; i++) {
                                x[i][j][l] = (x0[i][j][l] + a * (x[i - 1][j][l] + x[i + 1][j][l] + x[i][j - 1][l] + x[i][j + 1][l] + x[i][j][l - 1] + x[i][j][l + 1])) * cRecip;
                            }
                        }
                    }
                    this.set_bnd(b, x);
                }
            }

            diffuse(b, x, x0, diff) {
                const a = this.dt * diff * this.N * this.N;
                this.lin_solve(b, x, x0, a, 1 + 6 * a);
            }

            advect(b, d, d0, u, v, w) {
                const dt0 = this.dt * this.N;
                for (let l = 1; l <= this.N; l++) { for (let j = 1; j <= this.N; j++) { for (let i = 1; i <= this.N; i++) {
                    let x = i - dt0 * u[i][j][l]; let y = j - dt0 * v[i][j][l]; let z = l - dt0 * w[i][j][l];
                    if (x < 0.5) x = 0.5; if (x > this.N + 0.5) x = this.N + 0.5; let i0 = Math.floor(x); let i1 = i0 + 1;
                    if (y < 0.5) y = 0.5; if (y > this.N + 0.5) y = this.N + 0.5; let j0 = Math.floor(y); let j1 = j0 + 1;
                    if (z < 0.5) z = 0.5; if (z > this.N + 0.5) z = this.N + 0.5; let l0 = Math.floor(z); let l1 = l0 + 1;
                    let s1 = x - i0; let s0 = 1 - s1; let t1 = y - j0; let t0 = 1 - t1; let r1 = z - l0; let r0 = 1 - r1;
                    d[i][j][l] = s0 * (t0 * r0 * d0[i0][j0][l0] + t1 * r0 * d0[i0][j1][l0] + t0 * r1 * d0[i0][j0][l1] + t1 * r1 * d0[i0][j1][l1]) +
                                 s1 * (t0 * r0 * d0[i1][j0][l0] + t1 * r0 * d0[i1][j1][l0] + t0 * r1 * d0[i1][j0][l1] + t1 * r1 * d0[i1][j1][l1]);
                }}}
                this.set_bnd(b, d);
            }
            
            project() {
                const h = 1.0 / this.N;
                for (let l = 1; l <= this.N; l++) { for (let j = 1; j <= this.N; j++) { for (let i = 1; i <= this.N; i++) {
                    this.div[i][j][l] = -0.5 * h * (this.u[i+1][j][l] - this.u[i-1][j][l] + this.v[i][j+1][l] - this.v[i][j-1][l] + this.w[i][j][l+1] - this.w[i][j][l-1]);
                    this.p[i][j][l] = 0;
                }}}
                this.set_bnd(0, this.div); this.set_bnd(0, this.p);
                this.lin_solve(0, this.p, this.div, 1, 6);
                for (let l = 1; l <= this.N; l++) { for (let j = 1; j <= this.N; j++) { for (let i = 1; i <= this.N; i++) {
                    this.u[i][j][l] -= 0.5 * (this.p[i+1][j][l] - this.p[i-1][j][l]) / h;
                    this.v[i][j][l] -= 0.5 * (this.p[i][j+1][l] - this.p[i][j-1][l]) / h;
                    this.w[i][j][l] -= 0.5 * (this.p[i][j][l+1] - this.p[i][j][l-1]) / h;
                }}}
                this.set_bnd(1, this.u); this.set_bnd(2, this.v); this.set_bnd(3, this.w);
            }

            fluid_step() {
                [this.u_prev, this.u] = [this.u, this.u_prev]; [this.v_prev, this.v] = [this.v, this.v_prev]; [this.w_prev, this.w] = [this.w, this.w_prev];
                this.diffuse(1, this.u, this.u_prev, this.viscosity);
                this.diffuse(2, this.v, this.v_prev, this.viscosity);
                this.diffuse(3, this.w, this.w_prev, this.viscosity);
                this.project();
                [this.u_prev, this.u] = [this.u, this.u_prev]; [this.v_prev, this.v] = [this.v, this.v_prev]; [this.w_prev, this.w] = [this.w, this.w_prev];
                this.advect(1, this.u, this.u_prev, this.u_prev, this.v_prev, this.w_prev);
                this.advect(2, this.v, this.v_prev, this.u_prev, this.v_prev, this.w_prev);
                this.advect(3, this.w, this.w_prev, this.u_prev, this.v_prev, this.w_prev);
                this.project();
                [this.density_prev, this.density] = [this.density, this.density_prev];
                this.diffuse(0, this.density, this.density_prev, 0);
                [this.density_prev, this.density] = [this.density, this.density_prev];
                this.advect(0, this.density, this.density_prev, this.u, this.v, this.w);
            }
            
            calculateVorticity(source = this) {
                const omegaX = this.create3DArray(); const omegaY = this.create3DArray(); const omegaZ = this.create3DArray();
                const h2 = 2 * this.dx;
                for (let i = 1; i <= this.N; i++) for (let j = 1; j <= this.N; j++) for (let l = 1; l <= this.N; l++) {
                    const dWdY = (source.w[i][j+1][l] - source.w[i][j-1][l]) / h2;
                    const dVdZ = (source.v[i][j][l+1] - source.v[i][j][l-1]) / h2;
                    omegaX[i][j][l] = dWdY - dVdZ;
                    const dUdZ = (source.u[i][j][l+1] - source.u[i][j][l-1]) / h2;
                    const dWdX = (source.w[i+1][j][l] - source.w[i-1][j][l]) / h2;
                    omegaY[i][j][l] = dUdZ - dWdX;
                    const dVdX = (source.v[i+1][j][l] - source.v[i-1][j][l]) / h2;
                    const dUdY = (source.u[i][j+1][l] - source.u[i][j-1][l]) / h2;
                    omegaZ[i][j][l] = dVdX - dUdY;
                }
                return { omegaX, omegaY, omegaZ };
            }

            calculateVorticityMagnitude(vorticity) {
                const vorticityMag = this.create3DArray();
                 for (let i = 1; i <= this.N; i++) for (let j = 1; j <= this.N; j++) for (let l = 1; l <= this.N; l++) {
                    vorticityMag[i][j][l] = Math.sqrt(vorticity.omegaX[i][j][l]**2 + vorticity.omegaY[i][j][l]**2 + vorticity.omegaZ[i][j][l]**2);
                 }
                 return vorticityMag;
            }

            calculateHelicity(vorticity, source = this) {
                let helicity = 0;
                for (let i = 1; i <= this.N; i++) for (let j = 1; j <= this.N; j++) for (let l = 1; l <= this.N; l++) {
                    helicity += source.u[i][j][l] * vorticity.omegaX[i][j][l] +
                                source.v[i][j][l] * vorticity.omegaY[i][j][l] +
                                source.w[i][j][l] * vorticity.omegaZ[i][j][l];
                }
                return helicity / (this.N**3);
            }

            calculateMetric(metricFunc) {
                let total = 0;
                for (let i = 1; i <= this.N; i++) for (let j = 1; j <= this.N; j++) for (let l = 1; l <= this.N; l++) {
                    total += metricFunc(i, j, l);
                }
                return total / (this.N * this.N * this.N);
            }

            getDistribution(dataSourceFunc, numBins = 20, range = null) {
                const values = [];
                for (let i = 1; i <= this.N; i++) for (let j = 1; j <= this.N; j++) for (let l = 1; l <= this.N; l++) {
                    values.push(dataSourceFunc(i, j, l));
                }
                if (values.length === 0) return { labels: [], data: [] };
                
                let minVal, maxVal;
                if (range) {
                    [minVal, maxVal] = range;
                } else {
                    minVal = values[0]; maxVal = values[0];
                    for(let i = 1; i < values.length; i++) {
                        if(values[i] < minVal) minVal = values[i];
                        if(values[i] > maxVal) maxVal = values[i];
                    }
                }

                if (maxVal === minVal) return { labels: [maxVal.toPrecision(2)], data: [values.length] };
                
                const binWidth = (maxVal - minVal) / numBins;
                const histData = new Array(numBins).fill(0);
                const labels = Array.from({length: numBins}, (_, i) => {
                     const binStart = minVal + i * binWidth;
                     return `${binStart.toPrecision(2)}`;
                });
                
                values.forEach(val => {
                    let binIndex = Math.floor((val - minVal) / binWidth);
                    if (binIndex >= numBins) binIndex = numBins - 1;
                    if (binIndex < 0) binIndex = 0;
                    histData[binIndex]++;
                });
                return { labels, data: histData };
            }
        }

        // ==============================================================================
        // CLASS 2: THE INTERACTIVE DASHBOARD
        // ==============================================================================
        class SimulationDashboard {
            constructor() {
                this.simulator = null; this.renderer = null; this.scene = null; this.camera = null; this.controls = null;
                this.animationFrameId = null; this.isSimulationRunning = false; this.isSimulationPaused = false;
                this.currentSimStep = 0; this.totalSimSteps = 0;
                this.visualizationMode = 'velocity';
                this.geminiApiKey = "";
                this.tooltipsEnabled = false;

                this.simulationSnapshots = [];
                this.simulationTimeSteps = [];

                this.velocityArrows = new THREE.Group(); this.densitySpheres = new THREE.Group(); this.vorticitySpheres = new THREE.Group();
                
                this.metricsHistory = { ke: [], enstrophy: [], helicity: [], maxVort: [], time: [] };
                this.maxMetrics = { ke: 0, enstrophy: 0, helicity: 0, maxVel: 0, maxVort: 0 };
                this.charts = {};

                this.elements = {
                    paramGridSize: document.getElementById('paramGridSize'), inputGridSize: document.getElementById('inputGridSize'),
                    paramViscosity: document.getElementById('paramViscosity'), inputViscosity: document.getElementById('inputViscosity'),
                    paramDt: document.getElementById('paramDt'), inputDt: document.getElementById('inputDt'),
                    paramSimTime: document.getElementById('paramSimTime'), inputSimTime: document.getElementById('inputSimTime'),
                    paramInitCondition: document.getElementById('paramInitCondition'), paramVisualization: document.getElementById('paramVisualization'),
                    btnRun: document.getElementById('btnRun'), btnRunContent: document.getElementById('btnRunContent'), btnPauseResume: document.getElementById('btnPauseResume'),
                    btnRefresh: document.getElementById('btnRefresh'), btnExport: document.getElementById('btnExport'), btnHelp: document.getElementById('btnHelp'),
                    btnResults: document.getElementById('btnResults'), btnInterpretKids: document.getElementById('btnInterpretKids'), btnQA: document.getElementById('btnQA'), btnConversation: document.getElementById('btnConversation'), navierStokesAudio: document.getElementById('navierStokesAudio'),
                    geminiApiKeyInput: document.getElementById('geminiApiKeyInput'),
                    getApiKeyLink: document.getElementById('getApiKeyLink'),
                    progressBar: document.getElementById('progressBar'), threeJsContainer: document.getElementById('threeJsContainer'), performanceWarning: document.getElementById('performanceWarning'),
                    interpretationModal: document.getElementById('interpretationModal'), legalModal: document.getElementById('legalModal'), aiInterpretationModal: document.getElementById('aiInterpretationModal'),
                    closeModalButtons: document.querySelectorAll('.modal .close-button'), aiInterpretationContent: document.getElementById('aiInterpretationContent'),
                    legalLink: document.getElementById('legalLink'), acknowledgementsLink: document.getElementById('acknowledgementsLink'),
                    metricKE_current: document.getElementById('metricKE_current'), metricKE_max: document.getElementById('metricKE_max'),
                    metricEnstrophy_current: document.getElementById('metricEnstrophy_current'), metricEnstrophy_max: document.getElementById('metricEnstrophy_max'),
                    metricHelicity_current: document.getElementById('metricHelicity_current'), metricHelicity_max: document.getElementById('metricHelicity_max'),
                    metricMaxVel_current: document.getElementById('metricMaxVel_current'), metricMaxVel_max: document.getElementById('metricMaxVel_max'),
                    metricMaxVort_current: document.getElementById('metricMaxVort_current'), metricMaxVort_max: document.getElementById('metricMaxVort_max'),
                    metricAvgDiv_current: document.getElementById('metricAvgDiv_current'),
                    keChartCanvas: document.getElementById('keChartCanvas'), enstrophyChartCanvas: document.getElementById('enstrophyChartCanvas'), helicityChartCanvas: document.getElementById('helicityChartCanvas'), maxVortChartCanvas: document.getElementById('maxVortChartCanvas'),
                    velocityDistChartCanvas: document.getElementById('velocityDistChartCanvas'), vorticityDistChartCanvas: document.getElementById('vorticityDistChartCanvas'), pressureDistChartCanvas: document.getElementById('pressureDistChartCanvas'), helicityCosineDistChartCanvas: document.getElementById('helicityCosineDistChartCanvas'),
                    presetStableFlow: document.getElementById('presetStableFlow'), presetTurbulence: document.getElementById('presetTurbulence'), presetVortexStretching: document.getElementById('presetVortexStretching'), presetDensityTransport: document.getElementById('presetDensityTransport'),
                    simulationActivityIndicator: document.getElementById('simulationActivityIndicator'), percentageCounter: document.getElementById('percentageCounter'), liveSimSubtitle: document.getElementById('liveSimSubtitle'),
                    enableTooltips: document.getElementById('enableTooltips'), dynamicTooltip: document.getElementById('dynamicTooltip'), mainContentArea: document.getElementById('mainContentArea'),
                    tabAnalysis: document.getElementById('tabAnalysis'), 
                    analysisContentWrapper: document.getElementById('analysisContentWrapper'), 
                    analysisPlaceholder: document.getElementById('analysisPlaceholder'),
                    derivedMetricsWrapper: document.getElementById('derivedMetricsWrapper'),
                    metricRe: document.getElementById('metricRe'),
                    metricReTaylor: document.getElementById('metricReTaylor'),
                    metricEpsilon: document.getElementById('metricEpsilon'),
                    metricEta: document.getElementById('metricEta'),
                    metricLInt: document.getElementById('metricLInt'),
                    metricDxEtaRatio: document.getElementById('metricDxEtaRatio'),
                    playbackControls: document.getElementById('playbackControls'),
                    playbackSlider: document.getElementById('playbackSlider'),
                    playbackCurrentTime: document.getElementById('playbackCurrentTime'),
                    playbackTotalTime: document.getElementById('playbackTotalTime'),
                };
                
                this._boundHandleTooltipShow = this.handleTooltipShow.bind(this);
                this._boundHandleTooltipHide = this.handleTooltipHide.bind(this);
                
                this.setupEventListeners();
                this.updateAllSliderTrackColors();
                this.initThreeJs();
                this.refreshApplication();
            }

            setupSync(sliderId, inputId, fixedPoints = 0) {
                const slider = this.elements[sliderId];
                const input = this.elements[inputId];
                slider.oninput = () => {
                    input.value = parseFloat(slider.value).toFixed(fixedPoints);
                    this.updateSliderTrackColor(slider);
                };
                input.onchange = () => {
                    let value = parseFloat(input.value);
                    const min = parseFloat(slider.min);
                    const max = parseFloat(slider.max);
                    if (isNaN(value)) value = min;
                    value = Math.max(min, Math.min(max, value));
                    slider.value = value;
                    input.value = value.toFixed(fixedPoints);
                    this.updateSliderTrackColor(slider);
                };
            }

            updateSliderTrackColor(sliderElement) {
                if (!sliderElement) return;
                const value = parseFloat(sliderElement.value);
                const min = parseFloat(sliderElement.min);
                const max = parseFloat(sliderElement.max);
                const percentage = ((value - min) / (max - min)) * 100;
                sliderElement.style.setProperty('--slider-value-percent', `${percentage}%`);
            }
            
            updateAllSliderTrackColors() {
                this.updateSliderTrackColor(this.elements.paramGridSize);
                this.updateSliderTrackColor(this.elements.paramViscosity);
                this.updateSliderTrackColor(this.elements.paramDt);
                this.updateSliderTrackColor(this.elements.paramSimTime);
                this.updateSliderTrackColor(this.elements.playbackSlider);
            }

            setupEventListeners() {
                this.setupSync('paramGridSize', 'inputGridSize', 0);
                this.setupSync('paramViscosity', 'inputViscosity', 3);
                this.setupSync('paramDt', 'inputDt', 3);
                this.setupSync('paramSimTime', 'inputSimTime', 0);
                
                this.elements.paramVisualization.onchange = () => { this.visualizationMode = this.elements.paramVisualization.value; this.update3DVisualization(); };
                
                this.elements.btnRun.onclick = () => this.handleRunStop();
                this.elements.btnPauseResume.onclick = () => this.handlePauseResume();
                this.elements.btnRefresh.onclick = () => this.refreshApplication();
                this.elements.btnExport.onclick = () => this.exportData();
                this.elements.btnHelp.onclick = () => this.showModal('interpretationModal');
                this.elements.legalLink.onclick = (e) => { e.preventDefault(); this.showModal('legalModal'); };
                this.elements.acknowledgementsLink.onclick = (e) => { e.preventDefault(); this.showModal('interpretationModal', 'acknowledgementsSection'); };
                this.elements.getApiKeyLink.onclick = (e) => { e.preventDefault(); this.showModal('interpretationModal', 'apiKeyHelpSection'); };
                this.elements.closeModalButtons.forEach(btn => btn.onclick = () => this.hideAllModals());
                window.onclick = (event) => { if (event.target.classList.contains('modal')) this.hideAllModals(); };
                window.onresize = () => this.onWindowResize();
                
                this.elements.presetStableFlow.onclick = () => this.applyPreset({ gridSize: 16, viscosity: 0.08, dt: 0.01, simTime: 1000, initCondition: 'vortex', visualization: 'velocity' });
                this.elements.presetTurbulence.onclick = () => this.applyPreset({ gridSize: 24, viscosity: 0.005, dt: 0.01, simTime: 1500, initCondition: 'random', visualization: 'vorticity' });
                this.elements.presetVortexStretching.onclick = () => this.applyPreset({ gridSize: 20, viscosity: 0.01, dt: 0.01, simTime: 700, initCondition: 'vortex', visualization: 'velocity' });
                this.elements.presetDensityTransport.onclick = () => this.applyPreset({ gridSize: 16, viscosity: 0.02, dt: 0.01, simTime: 800, initCondition: 'jet', visualization: 'density' });

                this.elements.btnResults.onclick = () => this.interpretSimulationState('expert');
                this.elements.btnInterpretKids.onclick = () => this.interpretSimulationState('kids');
                this.elements.btnQA.onclick = () => this.interpretSimulationState('qa');
                this.elements.btnConversation.onclick = () => this.playConversationAudio();
                
                this.elements.enableTooltips.onchange = (e) => { this.tooltipsEnabled = e.target.checked; if(!this.tooltipsEnabled) this.handleTooltipHide(); };
                this.elements.mainContentArea.addEventListener('mouseover', this._boundHandleTooltipShow);
                this.elements.mainContentArea.addEventListener('mouseout', this._boundHandleTooltipHide);

                this.elements.geminiApiKeyInput.oninput = () => this.validateAndSetApiKey();
                
                this.elements.playbackSlider.oninput = () => this.handlePlaybackScrub();
            }
            
            async handleTooltipShow(event) {
                if (!this.tooltipsEnabled) return;
                const tooltipHost = event.target.closest('[data-tooltip-content]');
                if (tooltipHost) {
                    const tooltip = this.elements.dynamicTooltip;
                    tooltip.innerHTML = tooltipHost.dataset.tooltipContent;
                    tooltip.style.display = 'block';
                    tooltip.classList.remove('show');
                    if (window.MathJax?.typesetPromise) await window.MathJax.typesetPromise([tooltip]);
                    const hostRect = tooltipHost.getBoundingClientRect();
                    const tooltipRect = tooltip.getBoundingClientRect();
                    let newTop = hostRect.top - tooltipRect.height - 8;
                    let newLeft = hostRect.left + (hostRect.width / 2) - (tooltipRect.width / 2);
                    if (newTop < 5) newTop = hostRect.bottom + 8;
                    if (newLeft < 5) newLeft = 5;
                    if (newLeft + tooltipRect.width > window.innerWidth) newLeft = window.innerWidth - tooltipRect.width - 5;
                    tooltip.style.left = `${newLeft + window.scrollX}px`;
                    tooltip.style.top = `${newTop + window.scrollY}px`;
                    tooltip.classList.add('show');
                }
            }

            handleTooltipHide() {
                const tooltip = this.elements.dynamicTooltip;
                if(tooltip) tooltip.classList.remove('show');
            }
            
            applyPreset(config) {
                if (this.isSimulationRunning) this.handleRunStop();
                this.elements.inputGridSize.value = config.gridSize;
                this.elements.paramGridSize.value = config.gridSize;
                this.elements.inputViscosity.value = config.viscosity.toFixed(3);
                this.elements.paramViscosity.value = config.viscosity;
                this.elements.inputDt.value = config.dt.toFixed(3);
                this.elements.paramDt.value = config.dt;
                this.elements.inputSimTime.value = config.simTime;
                this.elements.paramSimTime.value = config.simTime;
                this.elements.paramInitCondition.value = config.initCondition;
                this.elements.paramVisualization.value = config.visualization;
                this.updateAllSliderTrackColors();
                this.refreshApplication();
                this.handleRunStop();
            }

            initThreeJs() {
                const container = this.elements.threeJsContainer;
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf0f0f0);
                this.camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                this.camera.position.set(0.5, 0.5, 1.5);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                container.appendChild(this.renderer.domElement);
                
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.target.set(0.5, 0.5, 0.5);
                this.controls.enablePan = false; // Disable panning
                
                this.scene.add(new THREE.AmbientLight(0xcccccc));
                const box = new THREE.Box3(new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 1, 1));
                const helper = new THREE.Box3Helper(box, 0x333333);
                this.scene.add(helper);

                this.scene.add(this.velocityArrows, this.densitySpheres, this.vorticitySpheres);
                const animate = () => {
                    requestAnimationFrame(animate);
                    this.controls.update();
                    this.renderer.render(this.scene, this.camera);
                };
                animate();
            }
            
            onWindowResize() {
                const container = this.elements.threeJsContainer;
                this.camera.aspect = container.clientWidth / container.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                Object.values(this.charts).forEach(chart => chart.resize());
            }

            refreshApplication() {
                if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
                this.isSimulationRunning = false; this.isSimulationPaused = false; this.currentSimStep = 0;
                this.simulationSnapshots = [];
                this.simulationTimeSteps = [];
                this.elements.progressBar.style.width = '0%';
                
                this.elements.derivedMetricsWrapper.style.display = 'none';
                this.elements.analysisContentWrapper.style.display = 'none';
                this.elements.analysisPlaceholder.style.display = 'block';
                this.elements.analysisPlaceholder.textContent = 'Run a simulation to see detailed analysis and derived physical quantities here.';
                
                const N = parseInt(this.elements.paramGridSize.value);
                this.elements.performanceWarning.style.display = N > 24 ? 'block' : 'none';
                
                this.simulator = new FluidSimulator3D(N, parseFloat(this.elements.paramViscosity.value), parseFloat(this.elements.paramDt.value));
                this.totalSimSteps = parseInt(this.elements.paramSimTime.value);

                this.elements.playbackSlider.value = 0;
                this.elements.playbackSlider.max = this.totalSimSteps;
                this.elements.playbackCurrentTime.textContent = 'Step: 0';
                this.elements.playbackTotalTime.textContent = `Total: ${this.totalSimSteps}`;
                this.updateSliderTrackColor(this.elements.playbackSlider);
                
                const initType = this.elements.paramInitCondition.value;
                const center = Math.floor(N / 2) + 1;
                const radius = Math.floor(N / 4);
                if (initType === 'vortex') {
                    for (let i = 1; i <= N; i++) for (let j = 1; j <= N; j++) {
                        const dx_c = i - center; const dy_c = j - center;
                        const r = Math.sqrt(dx_c*dx_c + dy_c*dy_c);
                        if (r < radius && r > 1) { this.simulator.u[i][j][center] = -dy_c * 0.5; this.simulator.v[i][j][center] = dx_c * 0.5; }
                    }
                    this.simulator.density[center][center][center] = 10;
                } else if (initType === 'jet') {
                    for (let i = center - 2; i <= center + 2; i++) for (let j = center - 2; j <= center + 2; j++) {
                        this.simulator.w[i][j][1] = 10.0; this.simulator.density[i][j][1] = 10.0;
                    }
                } else if (initType === 'random') {
                    for (let i=1; i<=N; i++) for (let j=1; j<=N; j++) for (let l=1; l<=N; l++) {
                        this.simulator.u[i][j][l] = (Math.random() - 0.5) * 0.1;
                        this.simulator.v[i][j][l] = (Math.random() - 0.5) * 0.1;
                        this.simulator.density[i][j][l] = Math.random() > 0.9 ? 1 : 0;
                    }
                }
                this.resetMetrics();
                this.update3DVisualization();
                this.updateButtonStates();
            }

            finalizeSimulation() {
                this.isSimulationRunning = false;
                this.updateButtonStates();
                this.showAnalysis();
                this.elements.playbackSlider.max = this.totalSimSteps;
                this.elements.playbackSlider.value = this.currentSimStep;
                this.elements.playbackCurrentTime.textContent = `Step: ${this.currentSimStep}`;
                this.updateSliderTrackColor(this.elements.playbackSlider);
            }

            handleRunStop() {
                if (this.isSimulationRunning) {
                    this.finalizeSimulation();
                } else {
                    this.isSimulationRunning = true;
                    this.isSimulationPaused = false;
                    this.runSimulationLoop();
                    this.updateButtonStates();
                }
            }

            handlePauseResume() { if (this.isSimulationRunning) { this.isSimulationPaused = !this.isSimulationPaused; this.updateButtonStates(); } }

            runSimulationLoop() {
                if (this.isSimulationPaused || !this.isSimulationRunning) return;

                if (this.currentSimStep >= this.totalSimSteps) {
                    this.finalizeSimulation();
                    return;
                }
                this.simulator.fluid_step();
                this.currentSimStep++;

                const snapshot_interval = Math.max(1, Math.floor(this.totalSimSteps / 100));
                if (this.currentSimStep % snapshot_interval === 0 || this.currentSimStep === this.totalSimSteps - 1) {
                    const deepCopy = (arr) => arr.map(plane => plane.map(row => new Float32Array(row)));
                    this.simulationSnapshots.push({
                        u: deepCopy(this.simulator.u), v: deepCopy(this.simulator.v), w: deepCopy(this.simulator.w),
                        density: deepCopy(this.simulator.density), p: deepCopy(this.simulator.p),
                    });
                    this.simulationTimeSteps.push(this.currentSimStep);
                }

                if (this.currentSimStep % 5 === 0) { this.updateMetrics(); }
                this.elements.progressBar.style.width = `${(this.currentSimStep / this.totalSimSteps) * 100}%`;
                this.elements.percentageCounter.textContent = `${Math.round((this.currentSimStep / this.totalSimSteps) * 100)}%`;
                
                if (this.currentSimStep % 2 === 0) { this.update3DVisualization(); }
                
                this.animationFrameId = requestAnimationFrame(() => this.runSimulationLoop());
            }

            handlePlaybackScrub() {
                if (this.simulationSnapshots.length === 0) return;
                const currentStep = parseFloat(this.elements.playbackSlider.value);
                this.elements.playbackCurrentTime.textContent = `Step: ${Math.round(currentStep)}`;
                this.updateSliderTrackColor(this.elements.playbackSlider);
                const snapshotIndex = this.findSnapshotIndexForStep(currentStep);
                const selectedSnapshot = this.simulationSnapshots[snapshotIndex];
                this.update3DVisualization(selectedSnapshot);
            }

            findSnapshotIndexForStep(step) {
                if (this.simulationTimeSteps.length === 0) return 0;
                return this.simulationTimeSteps.reduce((prev, curr, i) =>
                    (Math.abs(curr - step) < Math.abs(this.simulationTimeSteps[prev] - step) ? i : prev), 0);
            }

            update3DVisualization(sourceData = this.simulator) {
                const N = this.simulator.N, dx = this.simulator.dx, offset = 0.5 * dx;
                const sampleRate = Math.max(1, Math.floor(N / 12));
                const MAX_VORT_FOR_COLOR = 20.0;
                
                this.velocityArrows.visible = this.visualizationMode === 'velocity';
                this.densitySpheres.visible = this.visualizationMode === 'density';
                this.vorticitySpheres.visible = this.visualizationMode === 'vorticity';
                const scene = this.velocityArrows.visible ? this.velocityArrows : (this.densitySpheres.visible ? this.densitySpheres : this.vorticitySpheres);
                while(scene.children.length) scene.remove(scene.children[0]);
                
                let vorticity = (this.visualizationMode === 'vorticity' || this.visualizationMode === 'velocity') ? this.simulator.calculateVorticity(sourceData) : null;
                let vorticityMag = vorticity ? this.simulator.calculateVorticityMagnitude(vorticity) : null;

                for (let i=1; i<=N; i+=sampleRate) for (let j=1; j<=N; j+=sampleRate) for (let l=1; l<=N; l+=sampleRate) {
                    const x_pos = (i - 1) * dx + offset; const y_pos = (j - 1) * dx + offset; const z_pos = (l - 1) * dx + offset;
                    if (this.visualizationMode === 'velocity') {
                        const velocity = new THREE.Vector3(sourceData.u[i][j][l], sourceData.v[i][j][l], sourceData.w[i][j][l]);
                        const mag = velocity.length();
                        if (mag > 0.01) {
                            const hue = (1 - Math.min(vorticityMag[i][j][l] / MAX_VORT_FOR_COLOR, 1.0)) * 0.4 + 0.0; // Green to Red
                            const arrow = new THREE.ArrowHelper(velocity.normalize(), new THREE.Vector3(x_pos, y_pos, z_pos), Math.min(mag * 2, dx * 1.5), new THREE.Color().setHSL(hue, 0.9, 0.5));
                            scene.add(arrow);
                        }
                    } else if (this.visualizationMode === 'density' && sourceData.density[i][j][l] > 0.1) {
                        const sphere = new THREE.Mesh(new THREE.SphereGeometry(dx * 0.4, 8, 8), new THREE.MeshBasicMaterial({ color: 0xfca5a5, transparent: true, opacity: Math.min(sourceData.density[i][j][l] * 0.5, 0.8) }));
                        sphere.position.set(x_pos, y_pos, z_pos); scene.add(sphere);
                    } else if (this.visualizationMode === 'vorticity' && vorticityMag[i][j][l] > 1.0) {
                        const sphere = new THREE.Mesh(new THREE.SphereGeometry(dx * 0.4, 8, 8), new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL((1 - Math.min(vorticityMag[i][j][l] / 50, 1.0)) * 0.4, 1.0, 0.5), transparent: true, opacity: Math.min(vorticityMag[i][j][l] * 0.1, 0.8) }));
                        sphere.position.set(x_pos, y_pos, z_pos); scene.add(sphere);
                    }
                }
            }

            resetMetrics() {
                this.metricsHistory = { ke: [], enstrophy: [], helicity: [], maxVort: [], time: [] };
                this.maxMetrics = { ke: 0, enstrophy: 0, helicity: 0, maxVel: 0, maxVort: 0 };
                ['metricKE_current', 'metricKE_max', 'metricEnstrophy_current', 'metricEnstrophy_max', 'metricHelicity_current', 'metricHelicity_max', 'metricAvgDiv_current'].forEach(id => this.elements[id].textContent = '0.0000');
                ['metricMaxVel_current', 'metricMaxVel_max', 'metricMaxVort_current', 'metricMaxVort_max'].forEach(id => this.elements[id].textContent = '0.000');
                Object.values(this.charts).forEach(chart => chart?.destroy());
                this.charts = {};
                this.initializeCharts();
            }

            updateMetrics() {
                const vorticity = this.simulator.calculateVorticity();
                const vorticityMag = this.simulator.calculateVorticityMagnitude(vorticity);
                const helicity = this.simulator.calculateHelicity(vorticity);
                const ke = this.simulator.calculateMetric((i,j,l) => 0.5 * (this.simulator.u[i][j][l]**2 + this.simulator.v[i][j][l]**2 + this.simulator.w[i][j][l]**2));
                const enstrophy = this.simulator.calculateMetric((i,j,l) => 0.5 * vorticityMag[i][j][l]**2);
                let maxVel = 0, maxVort = 0;
                for (let i = 1; i <= this.simulator.N; i++) for (let j = 1; j <= this.simulator.N; j++) for (let l = 1; l <= this.simulator.N; l++) {
                    maxVel = Math.max(maxVel, Math.sqrt(this.simulator.u[i][j][l]**2 + this.simulator.v[i][j][l]**2 + this.simulator.w[i][j][l]**2));
                    maxVort = Math.max(maxVort, vorticityMag[i][j][l]);
                }
                const avgDiv = this.simulator.calculateMetric((i,j,l) => Math.abs(-0.5/this.simulator.dx * (this.simulator.u[i+1][j][l] - this.simulator.u[i-1][j][l] + this.simulator.v[i][j+1][l] - this.simulator.v[i][j-1][l] + this.simulator.w[i][j][l+1] - this.simulator.w[i][j][l-1])));

                this.metricsHistory.ke.push(ke); this.metricsHistory.enstrophy.push(enstrophy); this.metricsHistory.helicity.push(helicity); this.metricsHistory.maxVort.push(maxVort); this.metricsHistory.time.push(this.currentSimStep);
                this.maxMetrics.ke = Math.max(this.maxMetrics.ke, ke); this.maxMetrics.enstrophy = Math.max(this.maxMetrics.enstrophy, enstrophy); this.maxMetrics.helicity = Math.max(this.maxMetrics.helicity, Math.abs(helicity));
                this.maxMetrics.maxVel = Math.max(this.maxMetrics.maxVel, maxVel); this.maxMetrics.maxVort = Math.max(this.maxMetrics.maxVort, maxVort);
                
                this.elements.metricKE_current.textContent = ke.toExponential(2); this.elements.metricKE_max.textContent = this.maxMetrics.ke.toExponential(2);
                this.elements.metricEnstrophy_current.textContent = enstrophy.toExponential(2); this.elements.metricEnstrophy_max.textContent = this.maxMetrics.enstrophy.toExponential(2);
                this.elements.metricHelicity_current.textContent = helicity.toExponential(2); this.elements.metricHelicity_max.textContent = this.maxMetrics.helicity.toExponential(2);
                this.elements.metricMaxVel_current.textContent = maxVel.toFixed(3); this.elements.metricMaxVel_max.textContent = this.maxMetrics.maxVel.toFixed(3);
                this.elements.metricMaxVort_current.textContent = maxVort.toFixed(3); this.elements.metricMaxVort_max.textContent = this.maxMetrics.maxVort.toFixed(3);
                this.elements.metricAvgDiv_current.textContent = avgDiv.toExponential(2);
                
                this.updateCharts();
            }

            initializeCharts() {
                const createChart = (canvasId, label, color) => {
                    if (!this.elements[canvasId]) return null;
                    const ctx = this.elements[canvasId].getContext('2d');
                    return new Chart(ctx, {
                        type: 'line', data: { labels: [], datasets: [{ label, data: [], borderColor: color, borderWidth: 2, pointRadius: 0, tension: 0.1 }] },
                        options: { 
                            responsive: true, maintainAspectRatio: false, 
                            layout: { padding: { left: 15 } },
                            scales: { x: { title: { display: true, text: 'Simulation Step' } }, y: { title: { display: true, text: label }, ticks: { callback: value => value.toExponential(1) } } }, 
                            plugins: { legend: { display: false }, title: {display: true, text: label} }
                        }
                    });
                };
                const createBarChart = (canvasId, label, color) => {
                    if (!this.elements[canvasId]) return null;
                    const ctx = this.elements[canvasId].getContext('2d');
                    return new Chart(ctx, {
                        type: 'bar', data: { labels: [], datasets: [{ label, data: [], backgroundColor: color }] },
                        options: { responsive: true, maintainAspectRatio: false, scales: { x: { title: { display: true, text: 'Magnitude Bins' } }, y: { title: { display: true, text: 'Frequency' }, beginAtZero: true } }, plugins: { legend: { display: false }, title: {display: true, text: label} } }
                    });
                }
                this.charts.ke = createChart('keChartCanvas', 'Kinetic Energy', '#4F46E5');
                this.charts.enstrophy = createChart('enstrophyChartCanvas', 'Enstrophy', '#EF4444');
                this.charts.helicity = createChart('helicityChartCanvas', 'Helicity', '#10B981');
                this.charts.maxVort = createChart('maxVortChartCanvas', 'Max Vorticity', '#8B5CF6');
                this.charts.velDist = createBarChart('velocityDistChartCanvas', 'Velocity Magnitude Distribution', 'rgba(79, 70, 229, 0.6)');
                this.charts.vortDist = createBarChart('vorticityDistChartCanvas', 'Vorticity Magnitude Distribution', 'rgba(239, 68, 68, 0.6)');
                this.charts.pressureDist = createBarChart('pressureDistChartCanvas', 'Pressure Distribution', 'rgba(16, 185, 129, 0.6)');
                this.charts.helicityCosineDist = createBarChart('helicityCosineDistChartCanvas', 'Helicity Cosine Distribution', 'rgba(139, 92, 246, 0.6)');
            }
            
            updateCharts() {
                if(this.charts.ke) {
                    this.charts.ke.data.labels = this.metricsHistory.time;
                    this.charts.ke.data.datasets[0].data = this.metricsHistory.ke;
                    this.charts.ke.update('none');
                }
                if(this.charts.enstrophy) {
                    this.charts.enstrophy.data.labels = this.metricsHistory.time;
                    this.charts.enstrophy.data.datasets[0].data = this.metricsHistory.enstrophy;
                    this.charts.enstrophy.update('none');
                }
                 if(this.charts.helicity) {
                    this.charts.helicity.data.labels = this.metricsHistory.time;
                    this.charts.helicity.data.datasets[0].data = this.metricsHistory.helicity;
                    this.charts.helicity.update('none');
                }
                if(this.charts.maxVort) {
                    this.charts.maxVort.data.labels = this.metricsHistory.time;
                    this.charts.maxVort.data.datasets[0].data = this.metricsHistory.maxVort;
                    this.charts.maxVort.update('none');
                }
            }

            showAnalysis() {
                this.elements.analysisPlaceholder.style.display = 'none';

                // Derived Metrics Calculation
                const finalKE = this.metricsHistory.ke.slice(-1)[0] || 0;
                const finalEnstrophy = this.metricsHistory.enstrophy.slice(-1)[0] || 0;
                const viscosity = this.simulator.viscosity;
                const N = this.simulator.N;
                const dx = 1.0 / N;

                if (viscosity > 0 && finalEnstrophy > 0 && finalKE > 0) {
                    const re = (Math.sqrt(2 * finalKE) * 1.0) / viscosity; // L=1
                    const reTaylor = (Math.sqrt(2) * finalKE) / (viscosity * Math.sqrt(finalEnstrophy));
                    const epsilon = 2 * viscosity * finalEnstrophy;
                    const eta = Math.pow((viscosity**3) / epsilon, 0.25);
                    const lInt = Math.pow(finalKE, 1.5) / epsilon;
                    const dxEtaRatio = dx / eta;

                    this.elements.metricRe.textContent = re.toFixed(2);
                    this.elements.metricReTaylor.textContent = reTaylor.toFixed(2);
                    this.elements.metricEpsilon.textContent = epsilon.toExponential(2);
                    this.elements.metricEta.textContent = eta.toExponential(3);
                    this.elements.metricLInt.textContent = lInt.toExponential(3);
                    this.elements.metricDxEtaRatio.textContent = dxEtaRatio.toFixed(2);

                    this.elements.derivedMetricsWrapper.style.display = 'block';
                } else {
                    this.elements.derivedMetricsWrapper.style.display = 'none';
                }
                
                // Distribution Plots Calculation
                this.elements.analysisContentWrapper.style.display = 'block';

                const finalVorticity = this.simulator.calculateVorticity();
                const finalVorticityMag = this.simulator.calculateVorticityMagnitude(finalVorticity);

                const velDistData = this.simulator.getDistribution((i,j,l) => Math.sqrt(this.simulator.u[i][j][l]**2 + this.simulator.v[i][j][l]**2 + this.simulator.w[i][j][l]**2));
                const vortDistData = this.simulator.getDistribution((i,j,l) => finalVorticityMag[i][j][l]);
                const pressureDistData = this.simulator.getDistribution((i,j,l) => this.simulator.p[i][j][l]);
                const helicityCosineDistData = this.simulator.getDistribution((i, j, l) => {
                    const u = this.simulator.u[i][j][l], v = this.simulator.v[i][j][l], w = this.simulator.w[i][j][l];
                    const ox = finalVorticity.omegaX[i][j][l], oy = finalVorticity.omegaY[i][j][l], oz = finalVorticity.omegaZ[i][j][l];
                    const dotProduct = u * ox + v * oy + w * oz;
                    const uMag = Math.sqrt(u*u + v*v + w*w);
                    const oMag = finalVorticityMag[i][j][l];
                    if (uMag < 1e-9 || oMag < 1e-9) return 0;
                    return dotProduct / (uMag * oMag);
                }, 21, [-1, 1]);

                this.charts.velDist.data.labels = velDistData.labels; this.charts.velDist.data.datasets[0].data = velDistData.data; this.charts.velDist.update();
                this.charts.vortDist.data.labels = vortDistData.labels; this.charts.vortDist.data.datasets[0].data = vortDistData.data; this.charts.vortDist.update();
                this.charts.pressureDist.data.labels = pressureDistData.labels; this.charts.pressureDist.data.datasets[0].data = pressureDistData.data; this.charts.pressureDist.update();
                this.charts.helicityCosineDist.data.labels = helicityCosineDistData.labels; this.charts.helicityCosineDist.data.datasets[0].data = helicityCosineDistData.data; this.charts.helicityCosineDist.update();
            }

            validateAndSetApiKey() {
                this.geminiApiKey = this.elements.geminiApiKeyInput.value.trim();
                this.updateButtonStates();
            }

            async interpretSimulationState(mode) {
                if (!this.geminiApiKey) {
                    this.showAiInterpretationModal(`<p class="text-red-600">Gemini API key is not provided. Please enter your API key.</p>`);
                    return;
                }
                if (!this.simulator || this.currentSimStep === 0) {
                    this.showAiInterpretationModal(`<p>Please run a simulation to generate data for interpretation.</p>`);
                    return;
                }
                
                this.showAiInterpretationModal();
                
                let prompt = `You are an expert in fluid dynamics interpreting a 3D Navier-Stokes simulation. Simulation parameters: Grid=${this.simulator.N}^3, Viscosity=${this.simulator.viscosity}, dt=${this.simulator.dt}. Current step ${this.currentSimStep}/${this.totalSimSteps}. Initial condition: ${this.elements.paramInitCondition.value}. Final Metrics: KE=${this.metricsHistory.ke.slice(-1)[0].toExponential(2)}, Enstrophy=${this.metricsHistory.enstrophy.slice(-1)[0].toExponential(2)}, Helicity=${this.metricsHistory.helicity.slice(-1)[0].toExponential(2)}, MaxVel=${this.maxMetrics.maxVel.toFixed(2)}, MaxVorticity=${this.maxMetrics.maxVort.toFixed(2)}. `;
                if (mode === 'expert') {
                    prompt += "Provide a conceptual analysis of the flow's behavior, discussing turbulence, energy cascade, helicity, and vortex dynamics. Use Markdown and LaTeX.";
                } else if (mode === 'kids') {
                    prompt = `You are a friendly scientist named Einstein. Explain what's happening in my 3D "super soup" simulation to a 10-year-old. My soup has a "stickiness" of ${this.simulator.viscosity}. I started it by '${this.elements.paramInitCondition.value}'. The soup's total "splash energy" is ${this.metricsHistory.ke.slice(-1)[0].toExponential(2)} and its "swirliness" is ${this.metricsHistory.enstrophy.slice(-1)[0].toExponential(2)}. The fastest drop is moving at ${this.maxMetrics.maxVel.toFixed(2)} and the fastest swirl is ${this.maxMetrics.maxVort.toFixed(2)}. Tell me a fun story about what my soup is doing!`;
                } else if (mode === 'qa') {
                    prompt = "Generate 5 insightful questions and detailed answers about the provided 3D fluid simulation data. Focus on the relationship between parameters (like viscosity) and outcomes (like turbulence, energy decay, and helicity). Format as a JSON array of objects, where each object has a 'question' and 'answer' key.";
                }

                try {
                    const genAI = new GoogleGenerativeAI({apiKey: this.geminiApiKey});
                    const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });
                    const generationConfig = (mode === 'qa') ? { responseMimeType: "application/json" } : {};
                    const result = await model.generateContent({
                        contents: [{ role: "user", parts: [{ text: prompt }] }],
                        generationConfig,
                    });
                    const response = result.response;
                    let text = response.text();

                    let htmlContent = '';
                    if (mode === 'qa') {
                        if (text.startsWith("```json")) {
                           text = text.substring(7, text.length - 3).trim();
                        }
                        const qaPairs = JSON.parse(text);
                        qaPairs.forEach((item, index) => {
                           htmlContent += `<div class="mb-4 p-3 border border-gray-200 rounded-md bg-gray-50"><h4 class="font-bold text-lg text-gray-800 mb-1">Q${index+1}: ${item.question}</h4><p class="text-gray-700">${item.answer.replace(/\n/g, '<br>')}</p></div>`;
                        });
                    } else {
                        htmlContent = text.replace(/\n/g, '<br>');
                    }
                    this.showAiInterpretationModal(htmlContent);
                    if (window.MathJax?.typesetPromise) window.MathJax.typesetPromise([this.elements.aiInterpretationContent]);
                } catch (e) {
                    this.showAiInterpretationModal(`<p class="text-red-600">Failed to get AI interpretation: ${e.message}. Please check your API key and network connection.</p>`);
                }
            }
            
            showAiInterpretationModal(content = '') {
                this.showModal('aiInterpretationModal');
                if (content) {
                    this.elements.aiInterpretationContent.innerHTML = content;
                } else {
                    this.elements.aiInterpretationContent.innerHTML = `<div class="flex justify-center items-center py-8"><span class="spinner w-8 h-8 !border-t-purple-500 !border-gray-200"></span><span id="aiProgressMessage" class="ml-2 text-gray-600">Generating...</span></div>`;
                }
            }

            playConversationAudio() {
                const audio = this.elements.navierStokesAudio;
                const btn = this.elements.btnConversation;
                if (audio.paused) { audio.play(); btn.textContent = `Pause Conversation`; } 
                else { audio.pause(); btn.textContent = `Conversation`; }
                audio.onended = () => { btn.textContent = `Conversation`; };
            }

            showModal(modalId, sectionId = null) {
                const modal = document.getElementById(modalId);
                modal.style.display = 'flex';
                if (window.MathJax?.typesetPromise) window.MathJax.typesetPromise([modal]);
                if (sectionId) document.getElementById(sectionId)?.scrollIntoView({ behavior: 'smooth' });
            }

            hideAllModals() {
                document.querySelectorAll('.modal').forEach(m => m.style.display = 'none');
            }

            updateButtonStates() {
                const setButtonState = (btn, enabled) => {
                    if (btn) { btn.disabled = !enabled; btn.classList.toggle('opacity-50', !enabled); btn.classList.toggle('cursor-not-allowed', !enabled); }
                };
                
                const hasData = this.currentSimStep > 0;
                const canInterpret = hasData && this.geminiApiKey.length > 0;
                const playbackControls = this.elements.playbackControls;
                const playbackSlider = this.elements.playbackSlider;

                setButtonState(this.elements.btnRefresh, !this.isSimulationRunning);
                setButtonState(this.elements.btnExport, hasData && !this.isSimulationRunning);
                setButtonState(this.elements.btnResults, canInterpret && !this.isSimulationRunning);
                setButtonState(this.elements.btnInterpretKids, canInterpret && !this.isSimulationRunning);
                setButtonState(this.elements.btnQA, canInterpret && !this.isSimulationRunning);
                
                this.elements.btnRun.classList.toggle('bg-red-600', this.isSimulationRunning);
                this.elements.btnRun.classList.toggle('hover:bg-red-700', this.isSimulationRunning);
                this.elements.btnRun.classList.toggle('bg-indigo-600', !this.isSimulationRunning);
                this.elements.btnRun.classList.toggle('hover:bg-indigo-700', !this.isSimulationRunning);
                this.elements.btnRunContent.classList.toggle('pulsing-text', this.isSimulationRunning && !this.isSimulationPaused);
                this.elements.btnRun.title = this.isSimulationRunning ? 'Stop Simulation' : 'Start Simulation';
                this.elements.btnRunContent.innerHTML = this.isSimulationRunning ? `<svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0zM9 10h6v4H9v-4z"></path></svg> Simulation` : `<svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M14.752 11.168L10 9.18v5.64l4.752-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg> Simulation`;

                setButtonState(this.elements.btnPauseResume, this.isSimulationRunning);
                this.elements.btnPauseResume.title = this.isSimulationPaused ? 'Resume Simulation' : 'Pause Simulation';
                this.elements.btnPauseResume.innerHTML = this.isSimulationPaused ? `<svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M14.752 11.168L10 9.18v5.64l4.752-2.132a1 1 0 000-1.664z"></path></svg> Simulation` : `<svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6"></path></svg> Simulation`;

                this.elements.simulationActivityIndicator.style.display = (this.isSimulationRunning && !this.isSimulationPaused) ? 'flex' : 'none';
                this.elements.liveSimSubtitle.innerHTML = (this.isSimulationRunning && !this.isSimulationPaused) ? '<span class="text-green-600-custom">ACTIVE</span>' : '<span class="text-red-500">INACTIVE</span>';

                if (this.isSimulationRunning) {
                    playbackControls.classList.add('playback-disabled');
                    playbackSlider.disabled = true;
                } else {
                    if (hasData) {
                        playbackControls.classList.remove('playback-disabled');
                        playbackSlider.disabled = false;
                    } else {
                        playbackControls.classList.add('playback-disabled');
                        playbackSlider.disabled = true;
                    }
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new SimulationDashboard();
        });
    </script>
</body>
</html>
